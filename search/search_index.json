{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"QuestMaster","text":"<p>QuestMaster is a platform for managing tabletop RPG games (e.g. D&amp;D 5e), built for Club JDR.</p> <p>It lets Game Masters create games with all the details \u2014 name, system, number of players, session dates \u2014 and lets players browse and register for them. The app integrates with Discord to automatically manage roles, channels, and notifications.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Discord authentication \u2014 users log in with their Discord account.</li> <li>Game management \u2014 GMs create and manage one-shots or campaigns.</li> <li>Session tracking \u2014 schedule sessions with calendar events.</li> <li>Achievements \u2014 trophy system for players and GMs.</li> <li>Discord integration \u2014 automatic role and channel management on the server.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Getting Started \u2014 set up a local development environment.</li> <li>Architecture \u2014 understand the data model, repositories, services, and exception hierarchy.</li> <li>Contributing \u2014 guidelines for contributing to the project.</li> <li>GitHub Repository</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing-to-questmaster","title":"Contributing to QuestMaster","text":"<p>Thanks for your interest in contributing! Here's how to get started.</p>"},{"location":"contributing/#getting-started","title":"Getting started","text":"<ol> <li>Fork the repo and create a branch from <code>main</code>.</li> <li>Set up your local environment \u2014 see the Getting Started Guide for instructions.</li> <li>Make your changes, following the guidelines below.</li> <li>Open a pull request against <code>main</code>.</li> </ol>"},{"location":"contributing/#commit-messages","title":"Commit messages","text":"<p>All commits must follow the Conventional Commits format. Examples:</p> <ul> <li><code>feat: add trophy leaderboard</code></li> <li><code>fix: prevent duplicate session registrations</code></li> <li><code>refactor: extract game validation into service layer</code></li> <li><code>docs: update local setup instructions</code></li> <li><code>test: add unit tests for UserService</code></li> </ul>"},{"location":"contributing/#code-style","title":"Code style","text":"<ul> <li>Format with Black: <code>black .</code></li> <li>Sort imports with isort: <code>isort .</code></li> <li>Lint with flake8: <code>flake8 website/</code></li> <li>Lint docstrings (google-style) with pydoclint: <code>pydoclint website/</code></li> </ul> <p>A pre-commit configuration is provided. Install the hooks to run these checks automatically before each commit:</p> <pre><code>pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contributing/#architecture","title":"Architecture","text":"<p>The codebase follows a layered architecture. When adding or modifying code, respect these boundaries:</p> Layer Location Responsibility Rules Models <code>website/models/</code> SQLAlchemy models, relationships, constraints No business logic, no Flask imports Repositories <code>website/repositories/</code> Data access (queries, CRUD) No validation, no business rules, no Flask context Services <code>website/services/</code> Business logic, validation, transactions No direct Flask request/session access Views <code>website/views/</code> HTTP handling (parse input, call services, return response) No business logic <p>New logic should go in the service layer. Views should stay thin.</p>"},{"location":"contributing/#tests","title":"Tests","text":"<ul> <li>Use <code>pytest</code></li> <li>Add or update tests when changing service logic</li> <li>Mock external services (Discord, VTT APIs)</li> <li>Run the test suite before pushing:</li> </ul> <pre><code>python -m pytest tests/ -m \"not integration\"\n</code></pre>"},{"location":"contributing/#ci-pipeline","title":"CI Pipeline","text":"<p>Every pull request is checked by the CI pipeline which runs:</p> <ul> <li>Conventional commit check \u2014 all commits must follow the conventional commits format.</li> <li>Linting \u2014 import ordering with isort, formatting with Black, static analysis with flake8 and docstring lint with pydoclint.</li> <li>Tests and coverage \u2014 pytest runs with coverage reported to SonarCloud for code quality analysis.</li> </ul> <p>On merge to <code>main</code>, release-please creates or updates a release PR. Merging that PR creates a GitHub release and a version tag automatically, the CI also pushes the Docker image to GHCR.</p> <p>Dependencies are kept up to date by Renovate, which opens PRs for new versions of Python packages, Docker base images, and GitHub Actions.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting issues","text":"<ul> <li>Bug report</li> <li>Feature request</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"getting-started/#discord-bot-and-test-server","title":"Discord bot and test server","text":"<p>The app authenticates users via Discord OAuth2 and interacts with a Discord server to manage roles and channels. You need:</p> <ol> <li> <p>A Discord application \u2014 create one at the Discord Developer Portal:</p> <ul> <li>Under OAuth2, note the Client ID and Client Secret.</li> <li>Add <code>http://localhost:8000/callback</code> as a redirect URI.</li> <li>Under Bot, create a bot and copy its Token.</li> <li>The bot needs the Manage Roles and Manage Channels permissions.</li> </ul> </li> <li> <p>A test Discord server with:</p> <ul> <li>Three roles: one for admins, one for GMs, and one for players.</li> <li>Three text channels: one for game posts, one for admin notifications, and one for unit test output.</li> <li>Invite your bot to this server with the permissions above.</li> </ul> </li> </ol> <p>You can get the IDs of the server, roles, and channels by enabling Developer Mode in Discord settings (App Settings &gt; Advanced), then right-clicking on the relevant item and selecting Copy ID.</p>"},{"location":"getting-started/#environment-variables","title":"Environment variables","text":"<p>Create a <code>.env</code> file at the root of the project with the values from the previous step:</p> <pre><code>FLASK_AUTH_SECRET=\"\"\nDISCORD_CLIENT_ID=\"\"\nDISCORD_CLIENT_SECRET=\"\"\nDISCORD_BOT_TOKEN=\"\"\nDISCORD_REDIRECT_URI=\"http://localhost:8000/callback\"\nDISCORD_GUILD_NAME=\"Club JDR TEST\"\nPOSTGRES_USER=\"clubjdr\"\nPOSTGRES_PASSWORD=\"\"\nPOSTGRES_DB=\"clubjdr\"\nPOSTGRES_HOST=\"db\" # localhost if using flask outside Docker\nREDIS_HOST=\"redis\" # localhost if using flask outside Docker\nDISCORD_GUILD_ID=\"\"\nDISCORD_GM_ROLE_ID=\"\"\nDISCORD_ADMIN_ROLE_ID=\"\"\nDISCORD_PLAYER_ROLE_ID=\"\"\nPOSTS_CHANNEL_ID=\"\"\nADMIN_CHANNEL_ID=\"\"\nUNITTEST_CHANNEL_ID=\"\"\nFLASK_APP=\"website\"\n</code></pre>"},{"location":"getting-started/#using-docker-compose-recommended","title":"Using Docker Compose (recommended)","text":"<p>Build and start the complete stack:</p> <pre><code>docker compose up -d --build\n</code></pre> <p>On the first start, run the migrations to initialize the database:</p> <pre><code>docker compose run app flask db upgrade\n</code></pre> <p>Run the tests:</p> <pre><code># Unit tests only (no Discord credentials needed)\ndocker compose run app-test python -m pytest tests/ -m \"not integration\"\n\n# All tests including E2E and live Discord API tests\ndocker compose run app-test python -m pytest tests/\n</code></pre>"},{"location":"getting-started/#local-development","title":"Local development","text":"<p>Edit the <code>.env</code> to change <code>POSTGRES_HOST</code> and <code>REDIS_HOST</code> to <code>localhost</code>.</p> <p>Install the dependencies:</p> <pre><code>pip install -e \".[test,lint]\"\n</code></pre> <p>Start the database and redis:</p> <pre><code>docker compose up -d db redis\n</code></pre> <p>Run the migrations and start the app:</p> <pre><code>flask db upgrade\nflask run -p 8000\n</code></pre> <p>To run in debug mode (auto-reload on code changes):</p> <pre><code>flask --app website --debug run -p 8000\n</code></pre> <p>Run the tests:</p> <pre><code># Unit tests only (no Discord credentials needed)\npython -m pytest tests/ -m \"not integration\"\n\n# All tests including E2E and live Discord API tests (requires .env with Discord credentials)\npython -m pytest tests/\n</code></pre>"},{"location":"getting-started/#setup-test-database","title":"Setup test database","text":"<p>The test database is automatically set up (and destroyed afterwards) when running the tests. However, you can seed the database for manual testing by running:</p> <pre><code>flask setup-test-db\n</code></pre>"},{"location":"getting-started/#building-the-documentation-locally","title":"Building the documentation locally","text":"<p>Install the docs dependencies:</p> <pre><code>pip install -e \".[docs]\"\n</code></pre> <p>Serve the documentation with live reload:</p> <pre><code>mkdocs serve\n</code></pre> <p>The site will be available at http://127.0.0.1:8000.</p> <p>Note: the same port is used for the app. Either run bot separately or change the port using <code>-a localhost:&lt;port&gt;</code>.</p>"},{"location":"architecture/cli/","title":"CLI Commands","text":"<p>QuestMaster exposes Flask CLI commands for common setup tasks. They are registered in <code>website/extensions.py</code> and available via <code>flask &lt;command&gt;</code>.</p>"},{"location":"architecture/cli/#available-commands","title":"Available Commands","text":"Command Description <code>flask seed-trophies</code> Seed the database with the default set of trophies <code>flask setup-test-db</code> Initialize and seed a test database (skips if already initialized)"},{"location":"architecture/cli/#usage","title":"Usage","text":"<pre><code># Seed trophies into the database\nflask seed-trophies\n\n# Set up a fresh test database\nflask setup-test-db\n</code></pre>"},{"location":"architecture/client/","title":"Client","text":"<p>The client layer lives in <code>website/client/</code> and provides low-level HTTP clients for external API integrations.</p> <p>Clients:</p> <ul> <li>Handle HTTP requests, retries, and rate limiting</li> <li>Raise domain exceptions on failure (e.g. <code>DiscordAPIError</code>)</li> <li>Contain no business logic \u2014 that belongs in services</li> </ul>"},{"location":"architecture/client/#overview","title":"Overview","text":"Client Description <code>Discord</code> Low-level Discord REST API client with retry logic and rate-limit handling"},{"location":"architecture/client/#api-reference","title":"API Reference","text":"<p>Client layer for external API integrations.</p>"},{"location":"architecture/client/#website.client.Discord","title":"<code>Discord</code>","text":"<p>Low-level Discord API client.</p> <p>Handles HTTP requests to the Discord API with retry logic and rate limiting. For business logic, use DiscordService which wraps this client.</p> <p>Attributes:</p> Name Type Description <code>guild_id</code> <p>The Discord guild (server) ID.</p> <code>authorization</code> <p>The bot token for authentication.</p> <code>headers</code> <p>HTTP headers for API requests.</p> Source code in <code>website/client/discord.py</code> <pre><code>class Discord:\n    \"\"\"Low-level Discord API client.\n\n    Handles HTTP requests to the Discord API with retry logic and rate limiting.\n    For business logic, use DiscordService which wraps this client.\n\n    Attributes:\n        guild_id: The Discord guild (server) ID.\n        authorization: The bot token for authentication.\n        headers: HTTP headers for API requests.\n    \"\"\"\n\n    def __init__(self, guild_id, bot_token):\n        self.guild_id = guild_id\n        self.authorization = bot_token\n        self.headers = self._make_headers(self.authorization)\n\n    def _make_headers(self, authorization=\"\"):\n        headers = {\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n            \"authorization\": f\"Bot {authorization}\",\n        }\n        return headers\n\n    def _request(\n        self,\n        method,\n        endpoint,\n        *,\n        json=None,\n        params=None,\n        reason=None,\n        max_retries=3,\n    ):\n        \"\"\"Generic helper for all HTTP requests with retry + error handling.\"\"\"\n        url = f\"{DISCORD_API_BASE_URL}{endpoint}\"\n        headers = dict(self.headers)\n        if reason:\n            headers[\"X-Audit-Log-Reason\"] = reason\n\n        for attempt in range(max_retries):\n            r = requests.request(method, url, headers=headers, json=json, params=params)\n\n            # Handle rate limiting (HTTP 429)\n            if r.status_code == 429:\n                data = r.json()\n                retry_after = data.get(\"retry_after\", 1)\n                logger.warning(\"Rate limited by Discord. Retrying after %.2f s...\", retry_after)\n                time.sleep(float(retry_after))\n                continue\n\n            # Handle non-success codes\n            if not r.ok:\n                try:\n                    err_json = r.json()\n                except Exception:\n                    err_json = {\"message\": r.text}\n                raise DiscordAPIError(\n                    err_json.get(\"message\", \"Unknown error\"),\n                    status_code=r.status_code,\n                    response=err_json,\n                )\n\n            # Some endpoints return 204 No Content\n            if r.status_code == 204 or not r.content:\n                return {}\n\n            return r.json()\n\n        raise DiscordAPIError(\"Exceeded retry attempts\", status_code=429)\n\n    def get_user(self, user_id: str) -&gt; dict:\n        \"\"\"Fetch a guild member's data from Discord.\n\n        Args:\n            user_id: Discord user ID.\n\n        Returns:\n            Dict with member data including user, nick, and roles.\n        \"\"\"\n        return self._request(endpoint=f\"/guilds/{self.guild_id}/members/{user_id}\", method=\"GET\")\n\n    def send_message(self, content: str, channel_id: str) -&gt; dict:\n        \"\"\"Send a text message to a Discord channel.\n\n        Args:\n            content: Message content string.\n            channel_id: Target channel ID.\n\n        Returns:\n            Dict with the created message data.\n        \"\"\"\n        payload = {\n            \"content\": content,\n        }\n        return self._request(\n            endpoint=f\"/channels/{channel_id}/messages\", method=\"POST\", json=payload\n        )\n\n    def delete_message(self, msg_id: str, channel_id: str) -&gt; dict:\n        \"\"\"Delete a message from a Discord channel.\n\n        Args:\n            msg_id: Message ID to delete.\n            channel_id: Channel containing the message.\n        \"\"\"\n        return self._request(endpoint=f\"/channels/{channel_id}/messages/{msg_id}\", method=\"DELETE\")\n\n    def send_embed_message(self, embed: dict, channel_id: str) -&gt; dict:\n        \"\"\"Send an embed message to a Discord channel.\n\n        Args:\n            embed: Embed dict following Discord embed structure.\n            channel_id: Target channel ID.\n\n        Returns:\n            Dict with the created message data.\n        \"\"\"\n        payload = {\"embeds\": [embed]}\n        return self._request(\n            endpoint=f\"/channels/{channel_id}/messages\", method=\"POST\", json=payload\n        )\n\n    def edit_embed_message(self, msg_id: str, embed: dict, channel_id: str) -&gt; dict:\n        \"\"\"Edit an existing embed message.\n\n        Args:\n            msg_id: Message ID to edit.\n            embed: Updated embed dict.\n            channel_id: Channel containing the message.\n\n        Returns:\n            Dict with the updated message data.\n        \"\"\"\n        payload = {\"embeds\": [embed]}\n        return self._request(\n            endpoint=f\"/channels/{channel_id}/messages/{msg_id}\",\n            method=\"PATCH\",\n            json=payload,\n        )\n\n    def pin_message(self, msg_id: str, channel_id: str) -&gt; dict:\n        \"\"\"Pin an existing message.\n\n        Args:\n            msg_id: Message ID to pin.\n            channel_id: Channel containing the message.\n        \"\"\"\n        return self._request(\n            endpoint=f\"/channels/{channel_id}/messages/pins/{msg_id}\",\n            method=\"PUT\",\n        )\n\n    def create_channel(self, channel_name: str, parent_id: str, role_id: str, gm_id: str) -&gt; dict:\n        \"\"\"Create a text channel in the guild with role-based permissions.\n\n        Args:\n            channel_name: Display name for the channel.\n            parent_id: Parent category ID.\n            role_id: Role ID for player permissions.\n            gm_id: GM user ID for elevated permissions.\n\n        Returns:\n            Dict with the created channel data.\n        \"\"\"\n        payload = {\n            \"name\": \"-\".join(unidecode(channel_name).split()),\n            \"type\": 0,\n            \"parent_id\": parent_id,\n            \"permission_overwrites\": [\n                {\"id\": role_id, \"type\": 0, \"allow\": PLAYER_ROLE_PERMISSION},\n                {\"id\": self.get_role(self.guild_id)[\"id\"], \"type\": 0, \"deny\": \"1024\"},\n                {\"id\": gm_id, \"type\": 1, \"allow\": GM_ROLE_PERMISSION},\n            ],\n        }\n        return self._request(\n            endpoint=f\"/guilds/{self.guild_id}/channels\", method=\"POST\", json=payload\n        )\n\n    def get_channel(self, channel_id: str) -&gt; dict:\n        \"\"\"Fetch channel data from Discord.\n\n        Args:\n            channel_id: Discord channel ID.\n\n        Returns:\n            Dict with channel data.\n        \"\"\"\n        return self._request(endpoint=f\"/channels/{channel_id}\", method=\"GET\")\n\n    def delete_channel(self, channel_id: str) -&gt; dict:\n        \"\"\"Delete a Discord channel.\n\n        Args:\n            channel_id: Channel ID to delete.\n        \"\"\"\n        return self._request(endpoint=f\"/channels/{channel_id}\", method=\"DELETE\")\n\n    def create_role(self, role_name: str, permissions: str, color: int) -&gt; dict:\n        \"\"\"Create a new guild role.\n\n        Args:\n            role_name: Display name for the role.\n            permissions: Permission bitfield string.\n            color: Role color as integer.\n\n        Returns:\n            Dict with the created role data.\n        \"\"\"\n        payload = {\n            \"name\": \"_\".join(unidecode(role_name).split()),\n            \"permissions\": permissions,\n            \"color\": color,\n            \"mentionable\": True,\n        }\n        return self._request(\n            endpoint=f\"/guilds/{self.guild_id}/roles\", method=\"POST\", json=payload\n        )\n\n    def get_role(self, role_id: str) -&gt; dict:\n        \"\"\"Fetch a guild role by ID.\n\n        Args:\n            role_id: Role ID to look up.\n\n        Returns:\n            Dict with role data, or a fallback dict if not found.\n        \"\"\"\n        roles = self._request(endpoint=f\"/guilds/{self.guild_id}/roles\", method=\"GET\")\n        for role in roles:\n            if role[\"id\"] == role_id:\n                return role\n        return {\"message\": \"Unknown Role\"}\n\n    def delete_role(self, role_id: str) -&gt; dict:\n        \"\"\"Delete a guild role.\n\n        Args:\n            role_id: Role ID to delete.\n        \"\"\"\n        return self._request(endpoint=f\"/guilds/{self.guild_id}/roles/{role_id}\", method=\"DELETE\")\n\n    def add_role_to_user(self, user_id: str, role_id: str) -&gt; dict:\n        \"\"\"Assign a role to a guild member.\n\n        Args:\n            user_id: Discord user ID.\n            role_id: Role ID to assign.\n        \"\"\"\n        return self._request(\n            endpoint=f\"/guilds/{self.guild_id}/members/{user_id}/roles/{role_id}\",\n            method=\"PUT\",\n        )\n\n    def remove_role_from_user(self, user_id: str, role_id: str) -&gt; dict:\n        \"\"\"Remove a role from a guild member.\n\n        Args:\n            user_id: Discord user ID.\n            role_id: Role ID to remove.\n        \"\"\"\n        return self._request(\n            endpoint=f\"/guilds/{self.guild_id}/members/{user_id}/roles/{role_id}\",\n            method=\"DELETE\",\n        )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.get_user","title":"<code>get_user(user_id)</code>","text":"<p>Fetch a guild member's data from Discord.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with member data including user, nick, and roles.</p> Source code in <code>website/client/discord.py</code> <pre><code>def get_user(self, user_id: str) -&gt; dict:\n    \"\"\"Fetch a guild member's data from Discord.\n\n    Args:\n        user_id: Discord user ID.\n\n    Returns:\n        Dict with member data including user, nick, and roles.\n    \"\"\"\n    return self._request(endpoint=f\"/guilds/{self.guild_id}/members/{user_id}\", method=\"GET\")\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.send_message","title":"<code>send_message(content, channel_id)</code>","text":"<p>Send a text message to a Discord channel.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Message content string.</p> required <code>channel_id</code> <code>str</code> <p>Target channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with the created message data.</p> Source code in <code>website/client/discord.py</code> <pre><code>def send_message(self, content: str, channel_id: str) -&gt; dict:\n    \"\"\"Send a text message to a Discord channel.\n\n    Args:\n        content: Message content string.\n        channel_id: Target channel ID.\n\n    Returns:\n        Dict with the created message data.\n    \"\"\"\n    payload = {\n        \"content\": content,\n    }\n    return self._request(\n        endpoint=f\"/channels/{channel_id}/messages\", method=\"POST\", json=payload\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.delete_message","title":"<code>delete_message(msg_id, channel_id)</code>","text":"<p>Delete a message from a Discord channel.</p> <p>Parameters:</p> Name Type Description Default <code>msg_id</code> <code>str</code> <p>Message ID to delete.</p> required <code>channel_id</code> <code>str</code> <p>Channel containing the message.</p> required Source code in <code>website/client/discord.py</code> <pre><code>def delete_message(self, msg_id: str, channel_id: str) -&gt; dict:\n    \"\"\"Delete a message from a Discord channel.\n\n    Args:\n        msg_id: Message ID to delete.\n        channel_id: Channel containing the message.\n    \"\"\"\n    return self._request(endpoint=f\"/channels/{channel_id}/messages/{msg_id}\", method=\"DELETE\")\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.send_embed_message","title":"<code>send_embed_message(embed, channel_id)</code>","text":"<p>Send an embed message to a Discord channel.</p> <p>Parameters:</p> Name Type Description Default <code>embed</code> <code>dict</code> <p>Embed dict following Discord embed structure.</p> required <code>channel_id</code> <code>str</code> <p>Target channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with the created message data.</p> Source code in <code>website/client/discord.py</code> <pre><code>def send_embed_message(self, embed: dict, channel_id: str) -&gt; dict:\n    \"\"\"Send an embed message to a Discord channel.\n\n    Args:\n        embed: Embed dict following Discord embed structure.\n        channel_id: Target channel ID.\n\n    Returns:\n        Dict with the created message data.\n    \"\"\"\n    payload = {\"embeds\": [embed]}\n    return self._request(\n        endpoint=f\"/channels/{channel_id}/messages\", method=\"POST\", json=payload\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.edit_embed_message","title":"<code>edit_embed_message(msg_id, embed, channel_id)</code>","text":"<p>Edit an existing embed message.</p> <p>Parameters:</p> Name Type Description Default <code>msg_id</code> <code>str</code> <p>Message ID to edit.</p> required <code>embed</code> <code>dict</code> <p>Updated embed dict.</p> required <code>channel_id</code> <code>str</code> <p>Channel containing the message.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with the updated message data.</p> Source code in <code>website/client/discord.py</code> <pre><code>def edit_embed_message(self, msg_id: str, embed: dict, channel_id: str) -&gt; dict:\n    \"\"\"Edit an existing embed message.\n\n    Args:\n        msg_id: Message ID to edit.\n        embed: Updated embed dict.\n        channel_id: Channel containing the message.\n\n    Returns:\n        Dict with the updated message data.\n    \"\"\"\n    payload = {\"embeds\": [embed]}\n    return self._request(\n        endpoint=f\"/channels/{channel_id}/messages/{msg_id}\",\n        method=\"PATCH\",\n        json=payload,\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.pin_message","title":"<code>pin_message(msg_id, channel_id)</code>","text":"<p>Pin an existing message.</p> <p>Parameters:</p> Name Type Description Default <code>msg_id</code> <code>str</code> <p>Message ID to pin.</p> required <code>channel_id</code> <code>str</code> <p>Channel containing the message.</p> required Source code in <code>website/client/discord.py</code> <pre><code>def pin_message(self, msg_id: str, channel_id: str) -&gt; dict:\n    \"\"\"Pin an existing message.\n\n    Args:\n        msg_id: Message ID to pin.\n        channel_id: Channel containing the message.\n    \"\"\"\n    return self._request(\n        endpoint=f\"/channels/{channel_id}/messages/pins/{msg_id}\",\n        method=\"PUT\",\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.create_channel","title":"<code>create_channel(channel_name, parent_id, role_id, gm_id)</code>","text":"<p>Create a text channel in the guild with role-based permissions.</p> <p>Parameters:</p> Name Type Description Default <code>channel_name</code> <code>str</code> <p>Display name for the channel.</p> required <code>parent_id</code> <code>str</code> <p>Parent category ID.</p> required <code>role_id</code> <code>str</code> <p>Role ID for player permissions.</p> required <code>gm_id</code> <code>str</code> <p>GM user ID for elevated permissions.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with the created channel data.</p> Source code in <code>website/client/discord.py</code> <pre><code>def create_channel(self, channel_name: str, parent_id: str, role_id: str, gm_id: str) -&gt; dict:\n    \"\"\"Create a text channel in the guild with role-based permissions.\n\n    Args:\n        channel_name: Display name for the channel.\n        parent_id: Parent category ID.\n        role_id: Role ID for player permissions.\n        gm_id: GM user ID for elevated permissions.\n\n    Returns:\n        Dict with the created channel data.\n    \"\"\"\n    payload = {\n        \"name\": \"-\".join(unidecode(channel_name).split()),\n        \"type\": 0,\n        \"parent_id\": parent_id,\n        \"permission_overwrites\": [\n            {\"id\": role_id, \"type\": 0, \"allow\": PLAYER_ROLE_PERMISSION},\n            {\"id\": self.get_role(self.guild_id)[\"id\"], \"type\": 0, \"deny\": \"1024\"},\n            {\"id\": gm_id, \"type\": 1, \"allow\": GM_ROLE_PERMISSION},\n        ],\n    }\n    return self._request(\n        endpoint=f\"/guilds/{self.guild_id}/channels\", method=\"POST\", json=payload\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.get_channel","title":"<code>get_channel(channel_id)</code>","text":"<p>Fetch channel data from Discord.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>Discord channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with channel data.</p> Source code in <code>website/client/discord.py</code> <pre><code>def get_channel(self, channel_id: str) -&gt; dict:\n    \"\"\"Fetch channel data from Discord.\n\n    Args:\n        channel_id: Discord channel ID.\n\n    Returns:\n        Dict with channel data.\n    \"\"\"\n    return self._request(endpoint=f\"/channels/{channel_id}\", method=\"GET\")\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.delete_channel","title":"<code>delete_channel(channel_id)</code>","text":"<p>Delete a Discord channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>Channel ID to delete.</p> required Source code in <code>website/client/discord.py</code> <pre><code>def delete_channel(self, channel_id: str) -&gt; dict:\n    \"\"\"Delete a Discord channel.\n\n    Args:\n        channel_id: Channel ID to delete.\n    \"\"\"\n    return self._request(endpoint=f\"/channels/{channel_id}\", method=\"DELETE\")\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.create_role","title":"<code>create_role(role_name, permissions, color)</code>","text":"<p>Create a new guild role.</p> <p>Parameters:</p> Name Type Description Default <code>role_name</code> <code>str</code> <p>Display name for the role.</p> required <code>permissions</code> <code>str</code> <p>Permission bitfield string.</p> required <code>color</code> <code>int</code> <p>Role color as integer.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with the created role data.</p> Source code in <code>website/client/discord.py</code> <pre><code>def create_role(self, role_name: str, permissions: str, color: int) -&gt; dict:\n    \"\"\"Create a new guild role.\n\n    Args:\n        role_name: Display name for the role.\n        permissions: Permission bitfield string.\n        color: Role color as integer.\n\n    Returns:\n        Dict with the created role data.\n    \"\"\"\n    payload = {\n        \"name\": \"_\".join(unidecode(role_name).split()),\n        \"permissions\": permissions,\n        \"color\": color,\n        \"mentionable\": True,\n    }\n    return self._request(\n        endpoint=f\"/guilds/{self.guild_id}/roles\", method=\"POST\", json=payload\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.get_role","title":"<code>get_role(role_id)</code>","text":"<p>Fetch a guild role by ID.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Role ID to look up.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with role data, or a fallback dict if not found.</p> Source code in <code>website/client/discord.py</code> <pre><code>def get_role(self, role_id: str) -&gt; dict:\n    \"\"\"Fetch a guild role by ID.\n\n    Args:\n        role_id: Role ID to look up.\n\n    Returns:\n        Dict with role data, or a fallback dict if not found.\n    \"\"\"\n    roles = self._request(endpoint=f\"/guilds/{self.guild_id}/roles\", method=\"GET\")\n    for role in roles:\n        if role[\"id\"] == role_id:\n            return role\n    return {\"message\": \"Unknown Role\"}\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.delete_role","title":"<code>delete_role(role_id)</code>","text":"<p>Delete a guild role.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Role ID to delete.</p> required Source code in <code>website/client/discord.py</code> <pre><code>def delete_role(self, role_id: str) -&gt; dict:\n    \"\"\"Delete a guild role.\n\n    Args:\n        role_id: Role ID to delete.\n    \"\"\"\n    return self._request(endpoint=f\"/guilds/{self.guild_id}/roles/{role_id}\", method=\"DELETE\")\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.add_role_to_user","title":"<code>add_role_to_user(user_id, role_id)</code>","text":"<p>Assign a role to a guild member.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <code>role_id</code> <code>str</code> <p>Role ID to assign.</p> required Source code in <code>website/client/discord.py</code> <pre><code>def add_role_to_user(self, user_id: str, role_id: str) -&gt; dict:\n    \"\"\"Assign a role to a guild member.\n\n    Args:\n        user_id: Discord user ID.\n        role_id: Role ID to assign.\n    \"\"\"\n    return self._request(\n        endpoint=f\"/guilds/{self.guild_id}/members/{user_id}/roles/{role_id}\",\n        method=\"PUT\",\n    )\n</code></pre>"},{"location":"architecture/client/#website.client.Discord.remove_role_from_user","title":"<code>remove_role_from_user(user_id, role_id)</code>","text":"<p>Remove a role from a guild member.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <code>role_id</code> <code>str</code> <p>Role ID to remove.</p> required Source code in <code>website/client/discord.py</code> <pre><code>def remove_role_from_user(self, user_id: str, role_id: str) -&gt; dict:\n    \"\"\"Remove a role from a guild member.\n\n    Args:\n        user_id: Discord user ID.\n        role_id: Role ID to remove.\n    \"\"\"\n    return self._request(\n        endpoint=f\"/guilds/{self.guild_id}/members/{user_id}/roles/{role_id}\",\n        method=\"DELETE\",\n    )\n</code></pre>"},{"location":"architecture/exceptions/","title":"Exceptions","text":"<p>The exception hierarchy lives in <code>website/exceptions/</code> and provides structured, domain-specific errors used throughout the service layer.</p>"},{"location":"architecture/exceptions/#hierarchy","title":"Hierarchy","text":"<pre><code>QuestMasterError             # Base for all application errors\n  +-- NotFoundError          # Resource not found\n  +-- UnauthorizedError      # Permission denied\n  +-- ValidationError        # Input validation failure\n  +-- DatabaseError          # Database operation failure\n  +-- DiscordError           # Discord integration base error\n  |     +-- DiscordAPIError  # Discord API call failure\n  +-- GameError              # Game-related base error\n        +-- GameFullError          # Game has no open slots\n        +-- GameClosedError        # Game is not accepting registrations\n        +-- DuplicateRegistrationError  # User already registered\n        +-- SessionConflictError        # Session time conflict\n</code></pre>"},{"location":"architecture/exceptions/#usage","title":"Usage","text":"<p>Services raise these exceptions. Views catch them and translate to appropriate HTTP responses.</p> <pre><code>from website.exceptions import GameFullError\n\ndef register_player(game_id: int, user: User) -&gt; None:\n    game = game_repo.get_by_id(game_id)\n    if game.is_full:\n        raise GameFullError(f\"Game '{game.name}' is full\")\n    # ...\n</code></pre>"},{"location":"architecture/exceptions/#api-reference","title":"API Reference","text":"<p>Custom exception hierarchy for the QuestMaster application.</p>"},{"location":"architecture/exceptions/#website.exceptions.NotFoundError","title":"<code>NotFoundError</code>","text":"<p>               Bases: <code>QuestMasterError</code></p> <p>Resource not found.</p> Source code in <code>website/exceptions/base.py</code> <pre><code>class NotFoundError(QuestMasterError):\n    \"\"\"Resource not found.\"\"\"\n\n    http_status = 404\n\n    def __init__(self, message: str, resource_type=None, resource_id=None, **kwargs):\n        kwargs.setdefault(\"code\", \"NOT_FOUND\")\n        details = kwargs.pop(\"details\", {})\n        if resource_type is not None:\n            details[\"resource_type\"] = resource_type\n        if resource_id is not None:\n            details[\"resource_id\"] = resource_id\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.QuestMasterError","title":"<code>QuestMasterError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all QuestMaster errors.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Human-readable error description.</p> required <code>code</code> <code>str</code> <p>Machine-readable error code (e.g. \"GAME_FULL\").</p> <code>None</code> <code>details</code> <code>dict</code> <p>Additional context about the error.</p> <code>None</code> Source code in <code>website/exceptions/base.py</code> <pre><code>class QuestMasterError(Exception):\n    \"\"\"Base exception for all QuestMaster errors.\n\n    Args:\n        message: Human-readable error description.\n        code: Machine-readable error code (e.g. \"GAME_FULL\").\n        details: Additional context about the error.\n    \"\"\"\n\n    http_status = None\n\n    def __init__(self, message: str, code: str = None, details: dict = None):\n        self.message = message\n        self.code = code\n        self.details = details or {}\n        super().__init__(self.message)\n\n    def to_dict(self):\n        \"\"\"Serialize the error for API responses.\"\"\"\n        result = {\"error\": self.message, \"code\": self.code}\n        if self.details:\n            result[\"details\"] = self.details\n        return result\n\n    def __repr__(self):\n        parts = [f\"message={self.message!r}\"]\n        if self.code:\n            parts.append(f\"code={self.code!r}\")\n        if self.details:\n            parts.append(f\"details={self.details!r}\")\n        return f\"{self.__class__.__name__}({', '.join(parts)})\"\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.QuestMasterError.to_dict","title":"<code>to_dict()</code>","text":"<p>Serialize the error for API responses.</p> Source code in <code>website/exceptions/base.py</code> <pre><code>def to_dict(self):\n    \"\"\"Serialize the error for API responses.\"\"\"\n    result = {\"error\": self.message, \"code\": self.code}\n    if self.details:\n        result[\"details\"] = self.details\n    return result\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.UnauthorizedError","title":"<code>UnauthorizedError</code>","text":"<p>               Bases: <code>QuestMasterError</code></p> <p>User not authorized to perform this action.</p> Source code in <code>website/exceptions/base.py</code> <pre><code>class UnauthorizedError(QuestMasterError):\n    \"\"\"User not authorized to perform this action.\"\"\"\n\n    http_status = 403\n\n    def __init__(self, message: str, user_id=None, action=None, **kwargs):\n        kwargs.setdefault(\"code\", \"UNAUTHORIZED\")\n        details = kwargs.pop(\"details\", {})\n        if user_id is not None:\n            details[\"user_id\"] = user_id\n        if action is not None:\n            details[\"action\"] = action\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.DuplicateRegistrationError","title":"<code>DuplicateRegistrationError</code>","text":"<p>               Bases: <code>GameError</code></p> <p>Player already registered for this game.</p> Source code in <code>website/exceptions/business.py</code> <pre><code>class DuplicateRegistrationError(GameError):\n    \"\"\"Player already registered for this game.\"\"\"\n\n    def __init__(self, message: str, game_id=None, user_id=None, **kwargs):\n        kwargs.setdefault(\"code\", \"DUPLICATE_REGISTRATION\")\n        details = kwargs.pop(\"details\", {})\n        if game_id is not None:\n            details[\"game_id\"] = game_id\n        if user_id is not None:\n            details[\"user_id\"] = user_id\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.GameClosedError","title":"<code>GameClosedError</code>","text":"<p>               Bases: <code>GameError</code></p> <p>Game is closed for registration.</p> Source code in <code>website/exceptions/business.py</code> <pre><code>class GameClosedError(GameError):\n    \"\"\"Game is closed for registration.\"\"\"\n\n    def __init__(self, message: str, game_id=None, **kwargs):\n        kwargs.setdefault(\"code\", \"GAME_CLOSED\")\n        details = kwargs.pop(\"details\", {})\n        if game_id is not None:\n            details[\"game_id\"] = game_id\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.GameError","title":"<code>GameError</code>","text":"<p>               Bases: <code>QuestMasterError</code></p> <p>Game-related business logic error.</p> Source code in <code>website/exceptions/business.py</code> <pre><code>class GameError(QuestMasterError):\n    \"\"\"Game-related business logic error.\"\"\"\n\n    http_status = 409\n\n    def __init__(self, message: str, **kwargs):\n        kwargs.setdefault(\"code\", \"GAME_ERROR\")\n        super().__init__(message, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.GameFullError","title":"<code>GameFullError</code>","text":"<p>               Bases: <code>GameError</code></p> <p>Game has reached maximum players.</p> Source code in <code>website/exceptions/business.py</code> <pre><code>class GameFullError(GameError):\n    \"\"\"Game has reached maximum players.\"\"\"\n\n    def __init__(self, message: str, game_id=None, max_players=None, **kwargs):\n        kwargs.setdefault(\"code\", \"GAME_FULL\")\n        details = kwargs.pop(\"details\", {})\n        if game_id is not None:\n            details[\"game_id\"] = game_id\n        if max_players is not None:\n            details[\"max_players\"] = max_players\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.SessionConflictError","title":"<code>SessionConflictError</code>","text":"<p>               Bases: <code>GameError</code></p> <p>Game session overlaps with an existing session.</p> Source code in <code>website/exceptions/business.py</code> <pre><code>class SessionConflictError(GameError):\n    \"\"\"Game session overlaps with an existing session.\"\"\"\n\n    def __init__(self, message: str, game_id=None, **kwargs):\n        kwargs.setdefault(\"code\", \"SESSION_CONFLICT\")\n        details = kwargs.pop(\"details\", {})\n        if game_id is not None:\n            details[\"game_id\"] = game_id\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.DatabaseError","title":"<code>DatabaseError</code>","text":"<p>               Bases: <code>QuestMasterError</code></p> <p>Database operation failed.</p> Source code in <code>website/exceptions/database.py</code> <pre><code>class DatabaseError(QuestMasterError):\n    \"\"\"Database operation failed.\"\"\"\n\n    http_status = 500\n\n    def __init__(self, message: str, operation=None, **kwargs):\n        kwargs.setdefault(\"code\", \"DATABASE_ERROR\")\n        details = kwargs.pop(\"details\", {})\n        if operation is not None:\n            details[\"operation\"] = operation\n        super().__init__(message, details=details, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.DiscordAPIError","title":"<code>DiscordAPIError</code>","text":"<p>               Bases: <code>DiscordError</code></p> <p>Discord API request failed.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Description of the API error.</p> required <code>status_code</code> <code>int</code> <p>HTTP status code from the Discord API.</p> required <code>response</code> <code>dict</code> <p>The raw response body from Discord (optional).</p> <code>None</code> Source code in <code>website/exceptions/discord.py</code> <pre><code>class DiscordAPIError(DiscordError):\n    \"\"\"Discord API request failed.\n\n    Args:\n        message: Description of the API error.\n        status_code: HTTP status code from the Discord API.\n        response: The raw response body from Discord (optional).\n    \"\"\"\n\n    def __init__(self, message: str, status_code: int, response: dict = None):\n        self.status_code = status_code\n        self.response = response or {}\n        super().__init__(\n            message=f\"[{status_code}] {message}\",\n            code=f\"DISCORD_API_{status_code}\",\n            details={\"status_code\": status_code, \"response\": self.response},\n        )\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.DiscordError","title":"<code>DiscordError</code>","text":"<p>               Bases: <code>QuestMasterError</code></p> <p>Base Discord-related error.</p> Source code in <code>website/exceptions/discord.py</code> <pre><code>class DiscordError(QuestMasterError):\n    \"\"\"Base Discord-related error.\"\"\"\n\n    def __init__(self, message: str, **kwargs):\n        kwargs.setdefault(\"code\", \"DISCORD_ERROR\")\n        super().__init__(message, **kwargs)\n</code></pre>"},{"location":"architecture/exceptions/#website.exceptions.ValidationError","title":"<code>ValidationError</code>","text":"<p>               Bases: <code>QuestMasterError</code></p> <p>Input validation failed.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Description of the validation failure.</p> required <code>field</code> <code>str</code> <p>The field that failed validation (optional).</p> <code>None</code> <code>code</code> <code>str</code> <p>Machine-readable error code.</p> <code>None</code> <code>details</code> <code>dict</code> <p>Additional context about the error.</p> <code>None</code> Source code in <code>website/exceptions/validation.py</code> <pre><code>class ValidationError(QuestMasterError):\n    \"\"\"Input validation failed.\n\n    Args:\n        message: Description of the validation failure.\n        field: The field that failed validation (optional).\n        code: Machine-readable error code.\n        details: Additional context about the error.\n    \"\"\"\n\n    http_status = 400\n\n    def __init__(self, message: str, field: str = None, code: str = None, details: dict = None):\n        self.field = field\n        details = details or {}\n        if field:\n            details[\"field\"] = field\n        super().__init__(message=message, code=code or \"VALIDATION_ERROR\", details=details)\n</code></pre>"},{"location":"architecture/models/","title":"Models","text":"<p>The model layer lives in <code>website/models/</code> and contains SQLAlchemy models only \u2014 no business logic.</p> <p>Models define:</p> <ul> <li>Database columns and types</li> <li>Relationships and foreign keys</li> <li>Constraints (unique, not null, etc.)</li> <li>Serialization via <code>SerializableMixin</code></li> </ul>"},{"location":"architecture/models/#overview","title":"Overview","text":"Model Description <code>Game</code> A tabletop RPG game (one-shot or campaign) <code>GameSession</code> A scheduled session belonging to a game <code>GameEvent</code> Audit trail entry for game lifecycle events <code>User</code> A Discord-authenticated user <code>Trophy</code> An achievement definition <code>UserTrophy</code> A trophy awarded to a user <code>System</code> A tabletop RPG system (e.g. D&amp;D 5e, Pathfinder) <code>Channel</code> A Discord channel category managed by the app <code>SpecialEvent</code> A special community event (e.g. Halloween, Christmas) <code>Vtt</code> A virtual tabletop tool (e.g. Foundry, Roll20)"},{"location":"architecture/models/#api-reference","title":"API Reference","text":"<p>SQLAlchemy model definitions for QuestMaster.</p>"},{"location":"architecture/models/#website.models.Channel","title":"<code>Channel</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>Discord channel category used for game organization.</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Discord channel ID.</p> <code>type</code> <p>Game type this category serves (oneshot or campaign).</p> <code>size</code> <p>Current number of channels in this category.</p> Source code in <code>website/models/channel.py</code> <pre><code>class Channel(db.Model, SerializableMixin):\n    \"\"\"Discord channel category used for game organization.\n\n    Attributes:\n        id: Discord channel ID.\n        type: Game type this category serves (oneshot or campaign).\n        size: Current number of channels in this category.\n    \"\"\"\n\n    __tablename__ = \"channel\"\n\n    _exclude_fields = []\n    _relationship_fields = []\n\n    id = db.Column(db.String(), primary_key=True)\n    type = db.Column(ENUM(*GAME_TYPES, name=\"game_type_enum\", create_type=False), nullable=False)\n    size = db.Column(db.Integer(), nullable=False, default=0)\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create a Channel instance from a Python dict.\"\"\"\n        return cls(\n            id=data.get(\"id\"),\n            type=data.get(\"type\"),\n            size=data.get(\"size\", 0),\n        )\n\n    def update_from_dict(self, data):\n        \"\"\"Update the Channel instance from a dict (in place).\"\"\"\n        super().update_from_dict(data)\n        return self\n\n    def __repr__(self):\n        return f\"&lt;Channel id='{self.id}' type='{self.type}' size={self.size}&gt;\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Channel):\n            return NotImplemented\n        return self.id == other.id and self.type == other.type and self.size == other.size\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n</code></pre>"},{"location":"architecture/models/#website.models.Channel.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Channel instance from a Python dict.</p> Source code in <code>website/models/channel.py</code> <pre><code>@classmethod\ndef from_dict(cls, data):\n    \"\"\"Create a Channel instance from a Python dict.\"\"\"\n    return cls(\n        id=data.get(\"id\"),\n        type=data.get(\"type\"),\n        size=data.get(\"size\", 0),\n    )\n</code></pre>"},{"location":"architecture/models/#website.models.Channel.update_from_dict","title":"<code>update_from_dict(data)</code>","text":"<p>Update the Channel instance from a dict (in place).</p> Source code in <code>website/models/channel.py</code> <pre><code>def update_from_dict(self, data):\n    \"\"\"Update the Channel instance from a dict (in place).\"\"\"\n    super().update_from_dict(data)\n    return self\n</code></pre>"},{"location":"architecture/models/#website.models.Game","title":"<code>Game</code>","text":"<p>               Bases: <code>Model</code></p> <p>Represents a tabletop RPG game (oneshot or campaign).</p> Source code in <code>website/models/game.py</code> <pre><code>class Game(db.Model):\n    \"\"\"\n    Represents a tabletop RPG game (oneshot or campaign).\n    \"\"\"\n\n    __tablename__ = \"game\"\n    COLORS = {\"oneshot\": 0x198754, \"campaign\": 0x0D6EFD}\n\n    id = db.Column(db.BigInteger(), primary_key=True)\n    slug = db.Column(db.String(), unique=True, index=True)\n    name = db.Column(db.String(), nullable=False)\n    type = db.Column(\"type\", Enum(*GAME_TYPES, name=\"game_type_enum\"), nullable=False)\n    length = db.Column(db.String(), nullable=False)\n    gm_id = db.Column(db.String(), db.ForeignKey(\"user.id\"), nullable=False)\n    gm = db.relationship(\"User\", back_populates=\"games_gm\", foreign_keys=[gm_id])\n    system_id = db.Column(db.Integer(), db.ForeignKey(\"system.id\"), nullable=False)\n    vtt_id = db.Column(db.Integer(), db.ForeignKey(\"vtt.id\"), nullable=True)\n    description = db.Column(db.Text(), nullable=False)\n    restriction = db.Column(\n        \"restriction\", Enum(*RESTRICTIONS, name=\"restriction_enum\"), nullable=False\n    )\n    restriction_tags = db.Column(db.String())\n    party_size = db.Column(db.Integer(), nullable=False, default=4)\n    party_selection = db.Column(db.Boolean(), nullable=False, default=False)\n    players = db.relationship(\"User\", secondary=players_table, backref=\"games\")\n    xp = db.Column(\"experience\", Enum(*GAME_XP, name=\"game_xp_enum\"), default=\"all\")\n    date = db.Column(db.DateTime, nullable=False)\n    session_length = db.Column(db.DECIMAL(2, 1), nullable=False)\n    frequency = db.Column(\"frequency\", Enum(*GAME_FREQUENCIES, name=\"game_frequency_enum\"))\n    characters = db.Column(\"characters\", Enum(*GAME_CHAR, name=\"game_char_enum\"))\n    classification = db.Column(MutableDict.as_mutable(JSONB))\n    ambience = db.Column(pg.ARRAY(Enum(*AMBIENCES, name=\"game_ambience_enum\")))\n    complement = db.Column(db.Text())\n    img = db.Column(db.String())\n    sessions = db.relationship(\"GameSession\", backref=\"game\")\n    channel = db.Column(db.String())\n    msg_id = db.Column(db.String())\n    role = db.Column(db.String())\n    status = db.Column(\n        \"status\",\n        Enum(*GAME_STATUS, name=\"game_status_enum\"),\n        nullable=False,\n        server_default=\"draft\",\n    )\n    special_event_id = db.Column(db.Integer, db.ForeignKey(\"special_event.id\"), nullable=True)\n    special_event = db.relationship(\"SpecialEvent\", back_populates=\"games\")\n\n    @orm.validates(\"classification\")\n    def validate_classification(self, key, value):\n        \"\"\"Validate the classification JSON against the expected schema.\"\"\"\n        try:\n            if value:\n                CLASSIFICATION_SCHEMA.validate(value)\n            return value\n        except SchemaError:\n            raise ValidationError(\n                \"Invalid classification format.\",\n                field=\"classification\",\n                details={\"value\": value},\n            )\n\n    @orm.validates(\"party_size\")\n    def validate_party_size(self, key, value):\n        \"\"\"Ensure party size is at least one.\"\"\"\n        if int(value) &lt; 1:\n            raise ValidationError(\n                \"Number of players must be at least one.\",\n                field=\"party_size\",\n                details={\"value\": value},\n            )\n        return value\n\n    def _serialize_relation(self, obj):\n        \"\"\"Helper to serialize a single related object.\"\"\"\n        if obj and hasattr(obj, \"to_dict\"):\n            return obj.to_dict()\n        return None\n\n    def _serialize_relation_list(self, objects):\n        \"\"\"Helper to serialize a list of related objects.\"\"\"\n        return [obj.to_dict() for obj in objects if hasattr(obj, \"to_dict\")]\n\n    def _add_relationships_to_dict(self, data):\n        \"\"\"Add relationship data to the dictionary.\"\"\"\n        data[\"gm\"] = self._serialize_relation(getattr(self, \"gm\", None))\n        data[\"system\"] = self._serialize_relation(getattr(self, \"system\", None))\n        data[\"vtt\"] = self._serialize_relation(getattr(self, \"vtt\", None))\n        data[\"players\"] = self._serialize_relation_list(getattr(self, \"players\", []))\n        data[\"sessions\"] = self._serialize_relation_list(getattr(self, \"sessions\", []))\n        data[\"special_event\"] = self._serialize_relation(getattr(self, \"special_event\", None))\n\n    def to_dict(self, include_relationships: bool = False):\n        \"\"\"\n        Serialize the Game instance into a Python dict.\n\n        Args:\n            include_relationships: If True, includes nested objects\n                (gm, system, vtt, players, sessions). If False, only\n                includes IDs.\n        \"\"\"\n        data = {\n            \"id\": self.id,\n            \"slug\": self.slug,\n            \"name\": self.name,\n            \"type\": self.type,\n            \"length\": self.length,\n            \"gm_id\": self.gm_id,\n            \"system_id\": self.system_id,\n            \"vtt_id\": self.vtt_id,\n            \"description\": self.description,\n            \"restriction\": self.restriction,\n            \"restriction_tags\": self.restriction_tags,\n            \"party_size\": self.party_size,\n            \"party_selection\": self.party_selection,\n            \"xp\": self.xp,\n            \"date\": self.date.isoformat() if self.date else None,\n            \"session_length\": (float(self.session_length) if self.session_length else None),\n            \"frequency\": self.frequency,\n            \"characters\": self.characters,\n            \"classification\": self.classification,\n            \"ambience\": list(self.ambience) if self.ambience else None,\n            \"complement\": self.complement,\n            \"img\": self.img,\n            \"channel\": self.channel,\n            \"msg_id\": self.msg_id,\n            \"role\": self.role,\n            \"status\": self.status,\n            \"special_event_id\": self.special_event_id,\n        }\n\n        if include_relationships:\n            self._add_relationships_to_dict(data)\n        else:\n            data[\"player_ids\"] = [p.id for p in self.players]\n\n        return data\n\n    def to_json(self, include_relationships=False):\n        \"\"\"\n        Alias for to_dict() for API compatibility.\n        \"\"\"\n        return self.to_dict(include_relationships=include_relationships)\n\n    @property\n    def json(self):\n        \"\"\"\n        Property alias for JSON serialization.\n        \"\"\"\n        return self.to_dict()\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"\n        Create a Game instance from a Python dict.\n        Note: This does not handle relationships (gm, players, sessions, etc.).\n        Those should be set separately after creation.\n        \"\"\"\n        from datetime import datetime\n        from decimal import Decimal\n\n        # Convert date string to datetime if needed\n        date_value = data.get(\"date\")\n        if isinstance(date_value, str):\n            date_value = datetime.fromisoformat(date_value)\n\n        # Convert session_length to Decimal if needed\n        session_length_value = data.get(\"session_length\")\n        if session_length_value is not None and not isinstance(session_length_value, Decimal):\n            session_length_value = Decimal(str(session_length_value))\n\n        return cls(\n            id=data.get(\"id\"),\n            slug=data.get(\"slug\"),\n            name=data.get(\"name\"),\n            type=data.get(\"type\"),\n            length=data.get(\"length\"),\n            gm_id=data.get(\"gm_id\"),\n            system_id=data.get(\"system_id\"),\n            vtt_id=data.get(\"vtt_id\"),\n            description=data.get(\"description\"),\n            restriction=data.get(\"restriction\"),\n            restriction_tags=data.get(\"restriction_tags\"),\n            party_size=data.get(\"party_size\"),\n            party_selection=data.get(\"party_selection\"),\n            xp=data.get(\"xp\"),\n            date=date_value,\n            session_length=session_length_value,\n            frequency=data.get(\"frequency\"),\n            characters=data.get(\"characters\"),\n            classification=data.get(\"classification\"),\n            ambience=data.get(\"ambience\"),\n            complement=data.get(\"complement\"),\n            img=data.get(\"img\"),\n            channel=data.get(\"channel\"),\n            msg_id=data.get(\"msg_id\"),\n            role=data.get(\"role\"),\n            status=data.get(\"status\"),\n            special_event_id=data.get(\"special_event_id\"),\n        )\n\n    @classmethod\n    def from_json(cls, data):\n        \"\"\"\n        Alias for from_dict() for API compatibility.\n        \"\"\"\n        return cls.from_dict(data)\n\n    def update_from_dict(self, data):\n        \"\"\"\n        Update the Game instance from a dict (in place).\n        Protected fields (id, slug) are excluded from updates.\n        Relationships must be handled separately.\n        \"\"\"\n        from datetime import datetime\n        from decimal import Decimal\n\n        # Fields that should not be updated via this method\n        protected_fields = {\"id\", \"slug\"}\n\n        for key, value in data.items():\n            if key in protected_fields:\n                continue\n            if hasattr(self, key) and key not in [\n                \"gm\",\n                \"players\",\n                \"sessions\",\n                \"system\",\n                \"vtt\",\n                \"special_event\",\n            ]:\n                # Handle special conversions\n                if key == \"date\" and isinstance(value, str):\n                    value = datetime.fromisoformat(value)\n                elif (\n                    key == \"session_length\"\n                    and value is not None\n                    and not isinstance(value, Decimal)\n                ):\n                    value = Decimal(str(value))\n\n                setattr(self, key, value)\n        return self\n\n    def __repr__(self):\n        return (\n            f\"&lt;Game id={self.id} slug='{self.slug}' name='{self.name}' \"\n            f\"type='{self.type}' status='{self.status}'&gt;\"\n        )\n\n    def __eq__(self, other):\n        if not isinstance(other, Game):\n            return NotImplemented\n        return (\n            self.id == other.id\n            and self.slug == other.slug\n            and self.name == other.name\n            and self.type == other.type\n            and self.status == other.status\n        )\n\n    def __ne__(self, other):\n        result = self.__eq__(other)\n        if result is NotImplemented:\n            return NotImplemented\n        return not result\n</code></pre>"},{"location":"architecture/models/#website.models.Game.json","title":"<code>json</code>  <code>property</code>","text":"<p>Property alias for JSON serialization.</p>"},{"location":"architecture/models/#website.models.Game.validate_classification","title":"<code>validate_classification(key, value)</code>","text":"<p>Validate the classification JSON against the expected schema.</p> Source code in <code>website/models/game.py</code> <pre><code>@orm.validates(\"classification\")\ndef validate_classification(self, key, value):\n    \"\"\"Validate the classification JSON against the expected schema.\"\"\"\n    try:\n        if value:\n            CLASSIFICATION_SCHEMA.validate(value)\n        return value\n    except SchemaError:\n        raise ValidationError(\n            \"Invalid classification format.\",\n            field=\"classification\",\n            details={\"value\": value},\n        )\n</code></pre>"},{"location":"architecture/models/#website.models.Game.validate_party_size","title":"<code>validate_party_size(key, value)</code>","text":"<p>Ensure party size is at least one.</p> Source code in <code>website/models/game.py</code> <pre><code>@orm.validates(\"party_size\")\ndef validate_party_size(self, key, value):\n    \"\"\"Ensure party size is at least one.\"\"\"\n    if int(value) &lt; 1:\n        raise ValidationError(\n            \"Number of players must be at least one.\",\n            field=\"party_size\",\n            details={\"value\": value},\n        )\n    return value\n</code></pre>"},{"location":"architecture/models/#website.models.Game.to_dict","title":"<code>to_dict(include_relationships=False)</code>","text":"<p>Serialize the Game instance into a Python dict.</p> <p>Parameters:</p> Name Type Description Default <code>include_relationships</code> <code>bool</code> <p>If True, includes nested objects (gm, system, vtt, players, sessions). If False, only includes IDs.</p> <code>False</code> Source code in <code>website/models/game.py</code> <pre><code>def to_dict(self, include_relationships: bool = False):\n    \"\"\"\n    Serialize the Game instance into a Python dict.\n\n    Args:\n        include_relationships: If True, includes nested objects\n            (gm, system, vtt, players, sessions). If False, only\n            includes IDs.\n    \"\"\"\n    data = {\n        \"id\": self.id,\n        \"slug\": self.slug,\n        \"name\": self.name,\n        \"type\": self.type,\n        \"length\": self.length,\n        \"gm_id\": self.gm_id,\n        \"system_id\": self.system_id,\n        \"vtt_id\": self.vtt_id,\n        \"description\": self.description,\n        \"restriction\": self.restriction,\n        \"restriction_tags\": self.restriction_tags,\n        \"party_size\": self.party_size,\n        \"party_selection\": self.party_selection,\n        \"xp\": self.xp,\n        \"date\": self.date.isoformat() if self.date else None,\n        \"session_length\": (float(self.session_length) if self.session_length else None),\n        \"frequency\": self.frequency,\n        \"characters\": self.characters,\n        \"classification\": self.classification,\n        \"ambience\": list(self.ambience) if self.ambience else None,\n        \"complement\": self.complement,\n        \"img\": self.img,\n        \"channel\": self.channel,\n        \"msg_id\": self.msg_id,\n        \"role\": self.role,\n        \"status\": self.status,\n        \"special_event_id\": self.special_event_id,\n    }\n\n    if include_relationships:\n        self._add_relationships_to_dict(data)\n    else:\n        data[\"player_ids\"] = [p.id for p in self.players]\n\n    return data\n</code></pre>"},{"location":"architecture/models/#website.models.Game.to_json","title":"<code>to_json(include_relationships=False)</code>","text":"<p>Alias for to_dict() for API compatibility.</p> Source code in <code>website/models/game.py</code> <pre><code>def to_json(self, include_relationships=False):\n    \"\"\"\n    Alias for to_dict() for API compatibility.\n    \"\"\"\n    return self.to_dict(include_relationships=include_relationships)\n</code></pre>"},{"location":"architecture/models/#website.models.Game.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Game instance from a Python dict. Note: This does not handle relationships (gm, players, sessions, etc.). Those should be set separately after creation.</p> Source code in <code>website/models/game.py</code> <pre><code>@classmethod\ndef from_dict(cls, data):\n    \"\"\"\n    Create a Game instance from a Python dict.\n    Note: This does not handle relationships (gm, players, sessions, etc.).\n    Those should be set separately after creation.\n    \"\"\"\n    from datetime import datetime\n    from decimal import Decimal\n\n    # Convert date string to datetime if needed\n    date_value = data.get(\"date\")\n    if isinstance(date_value, str):\n        date_value = datetime.fromisoformat(date_value)\n\n    # Convert session_length to Decimal if needed\n    session_length_value = data.get(\"session_length\")\n    if session_length_value is not None and not isinstance(session_length_value, Decimal):\n        session_length_value = Decimal(str(session_length_value))\n\n    return cls(\n        id=data.get(\"id\"),\n        slug=data.get(\"slug\"),\n        name=data.get(\"name\"),\n        type=data.get(\"type\"),\n        length=data.get(\"length\"),\n        gm_id=data.get(\"gm_id\"),\n        system_id=data.get(\"system_id\"),\n        vtt_id=data.get(\"vtt_id\"),\n        description=data.get(\"description\"),\n        restriction=data.get(\"restriction\"),\n        restriction_tags=data.get(\"restriction_tags\"),\n        party_size=data.get(\"party_size\"),\n        party_selection=data.get(\"party_selection\"),\n        xp=data.get(\"xp\"),\n        date=date_value,\n        session_length=session_length_value,\n        frequency=data.get(\"frequency\"),\n        characters=data.get(\"characters\"),\n        classification=data.get(\"classification\"),\n        ambience=data.get(\"ambience\"),\n        complement=data.get(\"complement\"),\n        img=data.get(\"img\"),\n        channel=data.get(\"channel\"),\n        msg_id=data.get(\"msg_id\"),\n        role=data.get(\"role\"),\n        status=data.get(\"status\"),\n        special_event_id=data.get(\"special_event_id\"),\n    )\n</code></pre>"},{"location":"architecture/models/#website.models.Game.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Alias for from_dict() for API compatibility.</p> Source code in <code>website/models/game.py</code> <pre><code>@classmethod\ndef from_json(cls, data):\n    \"\"\"\n    Alias for from_dict() for API compatibility.\n    \"\"\"\n    return cls.from_dict(data)\n</code></pre>"},{"location":"architecture/models/#website.models.Game.update_from_dict","title":"<code>update_from_dict(data)</code>","text":"<p>Update the Game instance from a dict (in place). Protected fields (id, slug) are excluded from updates. Relationships must be handled separately.</p> Source code in <code>website/models/game.py</code> <pre><code>def update_from_dict(self, data):\n    \"\"\"\n    Update the Game instance from a dict (in place).\n    Protected fields (id, slug) are excluded from updates.\n    Relationships must be handled separately.\n    \"\"\"\n    from datetime import datetime\n    from decimal import Decimal\n\n    # Fields that should not be updated via this method\n    protected_fields = {\"id\", \"slug\"}\n\n    for key, value in data.items():\n        if key in protected_fields:\n            continue\n        if hasattr(self, key) and key not in [\n            \"gm\",\n            \"players\",\n            \"sessions\",\n            \"system\",\n            \"vtt\",\n            \"special_event\",\n        ]:\n            # Handle special conversions\n            if key == \"date\" and isinstance(value, str):\n                value = datetime.fromisoformat(value)\n            elif (\n                key == \"session_length\"\n                and value is not None\n                and not isinstance(value, Decimal)\n            ):\n                value = Decimal(str(value))\n\n            setattr(self, key, value)\n    return self\n</code></pre>"},{"location":"architecture/models/#website.models.GameEvent","title":"<code>GameEvent</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>Audit log entry recording an action on a game.</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Primary key.</p> <code>timestamp</code> <p>When the event occurred (UTC).</p> <code>action</code> <p>Event action type (create, edit, delete, etc.).</p> <code>game_id</code> <p>Foreign key to the related game.</p> <code>description</code> <p>Optional human-readable description.</p> Source code in <code>website/models/game_event.py</code> <pre><code>class GameEvent(db.Model, SerializableMixin):\n    \"\"\"Audit log entry recording an action on a game.\n\n    Attributes:\n        id: Primary key.\n        timestamp: When the event occurred (UTC).\n        action: Event action type (create, edit, delete, etc.).\n        game_id: Foreign key to the related game.\n        description: Optional human-readable description.\n    \"\"\"\n\n    __tablename__ = \"game_event\"\n\n    _exclude_fields = []\n    _relationship_fields = [\"game\", \"user_id\"]\n\n    id = db.Column(db.Integer, primary_key=True)\n    timestamp = db.Column(\n        db.DateTime(timezone=True),\n        default=lambda: datetime.now(timezone.utc),\n        nullable=False,\n    )\n    action = db.Column(Enum(*EVENT_ACTIONS, name=\"action_type_enum\"), nullable=False)\n    game_id = db.Column(db.Integer, db.ForeignKey(\"game.id\", ondelete=\"CASCADE\"), nullable=False)\n    description = db.Column(db.Text)\n    game = db.relationship(\"Game\", backref=\"events\", cascade=\"all,delete\")\n    user_id = db.Column(db.String(), db.ForeignKey(\"user.id\"), nullable=True)\n    user = db.relationship(\"User\")\n\n    __table_args__ = (\n        db.Index(\"ix_gameevent_timestamp\", \"timestamp\"),\n        db.Index(\"ix_gameevent_game\", \"game_id\"),\n    )\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create a GameEvent instance from a Python dict.\"\"\"\n        return cls(\n            id=data.get(\"id\"),\n            timestamp=data.get(\"timestamp\"),\n            action=data.get(\"action\"),\n            game_id=data.get(\"game_id\"),\n            description=data.get(\"description\"),\n            user_id=data.get(\"user_id\"),\n        )\n\n    def update_from_dict(self, data):\n        \"\"\"Update the GameEvent instance from a dict (in place).\"\"\"\n        super().update_from_dict(data)\n        return self\n\n    def __repr__(self):\n        return f\"&lt;GameEvent id={self.id} action='{self.action}' game_id={self.game_id}&gt;\"\n\n    def __eq__(self, other):\n        if not isinstance(other, GameEvent):\n            return NotImplemented\n        return (\n            self.id == other.id\n            and self.timestamp == other.timestamp\n            and self.action == other.action\n            and self.game_id == other.game_id\n            and self.description == other.description\n            and self.user_id == other.user_id\n        )\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n</code></pre>"},{"location":"architecture/models/#website.models.GameEvent.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a GameEvent instance from a Python dict.</p> Source code in <code>website/models/game_event.py</code> <pre><code>@classmethod\ndef from_dict(cls, data):\n    \"\"\"Create a GameEvent instance from a Python dict.\"\"\"\n    return cls(\n        id=data.get(\"id\"),\n        timestamp=data.get(\"timestamp\"),\n        action=data.get(\"action\"),\n        game_id=data.get(\"game_id\"),\n        description=data.get(\"description\"),\n        user_id=data.get(\"user_id\"),\n    )\n</code></pre>"},{"location":"architecture/models/#website.models.GameEvent.update_from_dict","title":"<code>update_from_dict(data)</code>","text":"<p>Update the GameEvent instance from a dict (in place).</p> Source code in <code>website/models/game_event.py</code> <pre><code>def update_from_dict(self, data):\n    \"\"\"Update the GameEvent instance from a dict (in place).\"\"\"\n    super().update_from_dict(data)\n    return self\n</code></pre>"},{"location":"architecture/models/#website.models.GameSession","title":"<code>GameSession</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>A scheduled play session belonging to a Game.</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Primary key.</p> <code>game_id</code> <p>Foreign key to the parent game.</p> <code>start</code> <p>Session start datetime.</p> <code>end</code> <p>Session end datetime.</p> Source code in <code>website/models/game_session.py</code> <pre><code>class GameSession(db.Model, SerializableMixin):\n    \"\"\"A scheduled play session belonging to a Game.\n\n    Attributes:\n        id: Primary key.\n        game_id: Foreign key to the parent game.\n        start: Session start datetime.\n        end: Session end datetime.\n    \"\"\"\n\n    __tablename__ = \"game_session\"\n\n    _exclude_fields = []\n    _relationship_fields = []\n\n    id = db.Column(db.BigInteger, primary_key=True)\n    game_id = db.Column(db.Integer, db.ForeignKey(\"game.id\"))\n    start = db.Column(db.DateTime, nullable=False)\n    end = db.Column(db.DateTime, nullable=False)\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(\n            id=data.get(\"id\"),\n            game_id=data.get(\"game_id\"),\n            start=data.get(\"start\"),\n            end=data.get(\"end\"),\n        )\n\n    def update_from_dict(self, data):\n        super().update_from_dict(data)\n        return self\n</code></pre>"},{"location":"architecture/models/#website.models.SpecialEvent","title":"<code>SpecialEvent</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>A themed event that groups related games (e.g. Halloween, conventions).</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Primary key.</p> <code>name</code> <p>Unique event name.</p> <code>emoji</code> <p>Optional emoji displayed alongside the event.</p> <code>color</code> <p>Optional color as integer for Discord embeds.</p> <code>active</code> <p>Whether the event is currently running.</p> Source code in <code>website/models/special_event.py</code> <pre><code>class SpecialEvent(db.Model, SerializableMixin):\n    \"\"\"A themed event that groups related games (e.g. Halloween, conventions).\n\n    Attributes:\n        id: Primary key.\n        name: Unique event name.\n        emoji: Optional emoji displayed alongside the event.\n        color: Optional color as integer for Discord embeds.\n        active: Whether the event is currently running.\n    \"\"\"\n\n    __tablename__ = \"special_event\"\n\n    _exclude_fields = []\n    _relationship_fields = [\"games\"]\n\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String, unique=True, nullable=False)\n    emoji = db.Column(db.String, nullable=True)\n    color = db.Column(db.Integer, nullable=True)\n    active = db.Column(db.Boolean, default=False, nullable=False)\n\n    games = db.relationship(\"Game\", back_populates=\"special_event\")\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(\n            id=data.get(\"id\"),\n            name=data.get(\"name\"),\n            emoji=data.get(\"emoji\"),\n            color=data.get(\"color\"),\n            active=data.get(\"active\", False),\n        )\n\n    def update_from_dict(self, data):\n        super().update_from_dict(data)\n        return self\n\n    def __str__(self):\n        hex_color = f\"#{self.color:06x}\" if isinstance(self.color, int) else (self.color or \"\")\n        return f\"{self.emoji} {self.name} ({hex_color})\"\n</code></pre>"},{"location":"architecture/models/#website.models.System","title":"<code>System</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>Represents a game system (e.g., D&amp;D 5e, Call of Cthulhu).</p> Source code in <code>website/models/system.py</code> <pre><code>class System(db.Model, SerializableMixin):\n    \"\"\"\n    Represents a game system (e.g., D&amp;D 5e, Call of Cthulhu).\n    \"\"\"\n\n    __tablename__ = \"system\"\n\n    _exclude_fields = []\n    _relationship_fields = [\"games_system\"]\n\n    id = db.Column(db.BigInteger, primary_key=True)\n    name = db.Column(db.String(), nullable=False, unique=True)\n    icon = db.Column(db.String(), nullable=True)\n\n    games_system = db.relationship(\"Game\", backref=\"system\")\n\n    @staticmethod\n    def get_systems():\n        \"\"\"Return a list of all Systems, ordered by name.\"\"\"\n        return System.query.order_by(\"name\").all()\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"\n        Create a System instance from a Python dict.\n        \"\"\"\n        return cls(\n            id=data.get(\"id\"),\n            name=data.get(\"name\"),\n            icon=data.get(\"icon\"),\n        )\n\n    def update_from_dict(self, data):\n        \"\"\"\n        Update the System instance from a dict (in place).\n        \"\"\"\n        super().update_from_dict(data)\n        return self\n\n    def __repr__(self):\n        return f\"&lt;System id={self.id} name='{self.name}' icon='{self.icon}'&gt;\"\n\n    def __eq__(self, other):\n        if not isinstance(other, System):\n            return NotImplemented\n        return self.id == other.id and self.name == other.name and self.icon == other.icon\n\n    def __ne__(self, other):\n        result = self.__eq__(other)\n        if result is NotImplemented:\n            return NotImplemented\n        return not result\n</code></pre>"},{"location":"architecture/models/#website.models.System.get_systems","title":"<code>get_systems()</code>  <code>staticmethod</code>","text":"<p>Return a list of all Systems, ordered by name.</p> Source code in <code>website/models/system.py</code> <pre><code>@staticmethod\ndef get_systems():\n    \"\"\"Return a list of all Systems, ordered by name.\"\"\"\n    return System.query.order_by(\"name\").all()\n</code></pre>"},{"location":"architecture/models/#website.models.System.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a System instance from a Python dict.</p> Source code in <code>website/models/system.py</code> <pre><code>@classmethod\ndef from_dict(cls, data):\n    \"\"\"\n    Create a System instance from a Python dict.\n    \"\"\"\n    return cls(\n        id=data.get(\"id\"),\n        name=data.get(\"name\"),\n        icon=data.get(\"icon\"),\n    )\n</code></pre>"},{"location":"architecture/models/#website.models.System.update_from_dict","title":"<code>update_from_dict(data)</code>","text":"<p>Update the System instance from a dict (in place).</p> Source code in <code>website/models/system.py</code> <pre><code>def update_from_dict(self, data):\n    \"\"\"\n    Update the System instance from a dict (in place).\n    \"\"\"\n    super().update_from_dict(data)\n    return self\n</code></pre>"},{"location":"architecture/models/#website.models.Trophy","title":"<code>Trophy</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>Trophy definition (badge template).</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Primary key.</p> <code>name</code> <p>Unique trophy name.</p> <code>unique</code> <p>If True, a user can only earn this trophy once.</p> <code>icon</code> <p>Path or URL to the trophy icon.</p> Source code in <code>website/models/trophy.py</code> <pre><code>class Trophy(db.Model, SerializableMixin):\n    \"\"\"Trophy definition (badge template).\n\n    Attributes:\n        id: Primary key.\n        name: Unique trophy name.\n        unique: If True, a user can only earn this trophy once.\n        icon: Path or URL to the trophy icon.\n    \"\"\"\n\n    __tablename__ = \"trophy\"\n\n    _exclude_fields = []\n    _relationship_fields = []\n\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(64), nullable=False, unique=True)\n    unique = db.Column(db.Boolean, default=False)\n    icon = db.Column(db.String(), nullable=True)\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(\n            id=data.get(\"id\"),\n            name=data.get(\"name\"),\n            unique=data.get(\"unique\", False),\n            icon=data.get(\"icon\"),\n        )\n\n    def update_from_dict(self, data):\n        super().update_from_dict(data)\n        return self\n\n    def __str__(self):\n        return self.name\n</code></pre>"},{"location":"architecture/models/#website.models.UserTrophy","title":"<code>UserTrophy</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>Association between a User and a Trophy.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <p>Foreign key to User.</p> <code>trophy_id</code> <p>Foreign key to Trophy.</p> <code>quantity</code> <p>Number of times this trophy was awarded.</p> Source code in <code>website/models/trophy.py</code> <pre><code>class UserTrophy(db.Model, SerializableMixin):\n    \"\"\"Association between a User and a Trophy.\n\n    Attributes:\n        user_id: Foreign key to User.\n        trophy_id: Foreign key to Trophy.\n        quantity: Number of times this trophy was awarded.\n    \"\"\"\n\n    __tablename__ = \"user_trophy\"\n\n    _exclude_fields = []\n    _relationship_fields = [\"user\", \"trophy\"]\n\n    user_id = db.Column(db.String(), db.ForeignKey(\"user.id\"), primary_key=True)\n    trophy_id = db.Column(db.Integer, db.ForeignKey(\"trophy.id\"), primary_key=True)\n    quantity = db.Column(db.Integer, nullable=False, default=1)\n\n    user = db.relationship(\"User\", back_populates=\"trophies\")\n    trophy = db.relationship(\"Trophy\")\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(\n            user_id=data.get(\"user_id\"),\n            trophy_id=data.get(\"trophy_id\"),\n            quantity=data.get(\"quantity\", 1),\n        )\n\n    def update_from_dict(self, data):\n        super().update_from_dict(data)\n        return self\n</code></pre>"},{"location":"architecture/models/#website.models.User","title":"<code>User</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>Discord-authenticated user.</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Discord user ID (17-21 digit string).</p> <code>name</code> <p>Display name (nick or global_name), refreshed from Discord.</p> <code>username</code> <p>Stable Discord username, used for slug generation.</p> <code>games_gm</code> <p>Games where this user is the GM.</p> <code>trophies</code> <p>User trophy associations.</p> Source code in <code>website/models/user.py</code> <pre><code>class User(db.Model, SerializableMixin):\n    \"\"\"Discord-authenticated user.\n\n    Attributes:\n        id: Discord user ID (17-21 digit string).\n        name: Display name (nick or global_name), refreshed from Discord.\n        username: Stable Discord username, used for slug generation.\n        games_gm: Games where this user is the GM.\n        trophies: User trophy associations.\n    \"\"\"\n\n    __tablename__ = \"user\"\n\n    _exclude_fields = []\n    _relationship_fields = [\"games_gm\", \"trophies\"]\n\n    id = db.Column(db.String(), primary_key=True)\n    name = db.Column(db.String(), nullable=False, index=True)\n    username = db.Column(db.String(), nullable=True)\n    not_player_as_of = db.Column(db.DateTime, nullable=True)\n    games_gm = db.relationship(\"Game\", back_populates=\"gm\")\n    trophies = db.relationship(\"UserTrophy\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n\n    def __init__(self, id, name=\"Inconnu\", username=None):\n        if not re.fullmatch(r\"\\d{17,21}\", id):\n            raise ValidationError(\"Invalid Discord UID.\", field=\"id\", details={\"value\": id})\n        self.id = id\n        self.name = name\n        self.username = username\n\n    @property\n    def slug_name(self) -&gt; str:\n        \"\"\"Return the stable name for slug generation.\n\n        Uses the Discord username (stable, lowercase) when available,\n        falling back to the display name.\n        \"\"\"\n        return self.username or self.name\n\n    @property\n    def display_name(self):\n        \"\"\"Display-friendly name, fetching from Discord if necessary.\"\"\"\n        if not self.name or self.name == \"Inconnu\":\n            try:\n                profile = get_user_profile(self.id)\n                self.name = profile[\"name\"]\n            except Exception:\n                return f\"&lt;@{self.id}&gt;\"\n        return f\"{self.name} &lt;@{self.id}&gt;\"\n\n    @property\n    def trophy_summary(self):\n        \"\"\"Return a list summarizing all trophies of the user.\"\"\"\n        summary = []\n        for ut in self.trophies:\n            summary.append(\n                {\n                    \"name\": ut.trophy.name,\n                    \"icon\": ut.trophy.icon,\n                    \"quantity\": ut.quantity,\n                }\n            )\n        return summary\n\n    @orm.reconstructor\n    def init_on_load(self):\n        \"\"\"Initialize user data after loading from the database.\n\n        Skips expensive Discord lookups when in admin context.\n        \"\"\"\n        self.avatar = getattr(self, \"avatar\", DEFAULT_AVATAR)\n        self.is_gm = False\n        self.is_admin = False\n        self.is_player = False\n\n        if not has_request_context():\n            profile = get_user_profile(self.id)\n            self.name = profile[\"name\"]\n            self.avatar = profile[\"avatar\"]\n            if profile.get(\"username\") and not self.username:\n                self.username = profile[\"username\"]\n            return\n\n        if request.path.startswith(\"/admin\"):\n            if not getattr(self, \"name\", None):\n                self.name = \"Inconnu\"\n            return\n\n        try:\n            profile = get_user_profile(self.id)\n            self.name = profile[\"name\"]\n            self.avatar = profile[\"avatar\"]\n            if profile.get(\"username\") and not self.username:\n                self.username = profile[\"username\"]\n        except Exception:\n            if not getattr(self, \"name\", None):\n                self.name = \"Inconnu\"\n            self.avatar = DEFAULT_AVATAR\n\n    def refresh_roles(self):\n        \"\"\"Refresh role info from Discord (cached for 5 minutes).\"\"\"\n        try:\n            roles = get_user_roles(self.id)\n            self.is_gm = current_app.config[\"DISCORD_GM_ROLE_ID\"] in roles\n            self.is_admin = current_app.config[\"DISCORD_ADMIN_ROLE_ID\"] in roles\n            self.is_player = current_app.config[\"DISCORD_PLAYER_ROLE_ID\"] in roles\n        except Exception:\n            self.is_gm = False\n            self.is_admin = False\n            self.is_player = False\n\n    def _serialize_relationship(self, rel_value):\n        \"\"\"Helper to serialize a relationship value (single object or list).\"\"\"\n        if rel_value is None:\n            return None\n        if isinstance(rel_value, list):\n            return [\n                item.to_dict() if hasattr(item, \"to_dict\") else str(item) for item in rel_value\n            ]\n        if hasattr(rel_value, \"to_dict\"):\n            return rel_value.to_dict()\n        return str(rel_value)\n\n    def _add_relationships_to_dict(self, data):\n        \"\"\"Add relationship data to the dictionary.\"\"\"\n        for rel_name in self._relationship_fields:\n            rel_value = getattr(self, rel_name, None)\n            data[rel_name] = self._serialize_relationship(rel_value)\n\n    def to_dict(self, include_relationships=False):\n        \"\"\"Serialize the User instance into a Python dict.\n\n        Includes dynamic attributes (avatar, roles) not stored in the database.\n        \"\"\"\n        data = {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"username\": self.username,\n            \"not_player_as_of\": (\n                self.not_player_as_of.isoformat() if self.not_player_as_of else None\n            ),\n            \"avatar\": getattr(self, \"avatar\", DEFAULT_AVATAR),\n            \"is_gm\": getattr(self, \"is_gm\", False),\n            \"is_admin\": getattr(self, \"is_admin\", False),\n            \"is_player\": getattr(self, \"is_player\", False),\n        }\n\n        if include_relationships:\n            self._add_relationships_to_dict(data)\n\n        return data\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"\"\"Create a User object from a dictionary.\n\n        Expected keys: 'id' (required), 'name' (optional).\n        Additional keys (avatar/is_gm/is_admin/is_player) will be set as attributes\n        on the created instance if present.\n        \"\"\"\n        if \"id\" not in data:\n            raise ValidationError(\"Missing id when creating User from dict.\", field=\"id\")\n        user = cls(\n            id=str(data[\"id\"]),\n            name=data.get(\"name\", \"Inconnu\"),\n            username=data.get(\"username\"),\n        )\n\n        # Optional attrs that are convenient to set from API payloads\n        if \"avatar\" in data:\n            user.avatar = data[\"avatar\"]\n        if \"is_gm\" in data:\n            user.is_gm = bool(data[\"is_gm\"])\n        if \"is_admin\" in data:\n            user.is_admin = bool(data[\"is_admin\"])\n        if \"is_player\" in data:\n            user.is_player = bool(data[\"is_player\"])\n        if \"not_player_as_of\" in data:\n            value = data[\"not_player_as_of\"]\n            if isinstance(value, str):\n                user.not_player_as_of = datetime.fromisoformat(value)\n            else:\n                user.not_player_as_of = value\n\n        return user\n\n    @classmethod\n    def from_json(cls, data):\n        \"\"\"Alias for from_dict() for API compatibility.\"\"\"\n        return cls.from_dict(data)\n\n    def update_from_dict(self, data: dict):\n        \"\"\"Update the user from a dictionary of fields.\"\"\"\n        for field in [\"name\", \"username\", \"not_player_as_of\"]:\n            if field in data:\n                setattr(self, field, data[field])\n\n    def __repr__(self):\n        return f\"{self.name} &lt;{self.id}&gt;\"\n\n    def __eq__(self, other):\n        if not isinstance(other, User):\n            return NotImplemented\n        return self.id == other.id and self.name == other.name\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n</code></pre>"},{"location":"architecture/models/#website.models.User.slug_name","title":"<code>slug_name</code>  <code>property</code>","text":"<p>Return the stable name for slug generation.</p> <p>Uses the Discord username (stable, lowercase) when available, falling back to the display name.</p>"},{"location":"architecture/models/#website.models.User.display_name","title":"<code>display_name</code>  <code>property</code>","text":"<p>Display-friendly name, fetching from Discord if necessary.</p>"},{"location":"architecture/models/#website.models.User.trophy_summary","title":"<code>trophy_summary</code>  <code>property</code>","text":"<p>Return a list summarizing all trophies of the user.</p>"},{"location":"architecture/models/#website.models.User.init_on_load","title":"<code>init_on_load()</code>","text":"<p>Initialize user data after loading from the database.</p> <p>Skips expensive Discord lookups when in admin context.</p> Source code in <code>website/models/user.py</code> <pre><code>@orm.reconstructor\ndef init_on_load(self):\n    \"\"\"Initialize user data after loading from the database.\n\n    Skips expensive Discord lookups when in admin context.\n    \"\"\"\n    self.avatar = getattr(self, \"avatar\", DEFAULT_AVATAR)\n    self.is_gm = False\n    self.is_admin = False\n    self.is_player = False\n\n    if not has_request_context():\n        profile = get_user_profile(self.id)\n        self.name = profile[\"name\"]\n        self.avatar = profile[\"avatar\"]\n        if profile.get(\"username\") and not self.username:\n            self.username = profile[\"username\"]\n        return\n\n    if request.path.startswith(\"/admin\"):\n        if not getattr(self, \"name\", None):\n            self.name = \"Inconnu\"\n        return\n\n    try:\n        profile = get_user_profile(self.id)\n        self.name = profile[\"name\"]\n        self.avatar = profile[\"avatar\"]\n        if profile.get(\"username\") and not self.username:\n            self.username = profile[\"username\"]\n    except Exception:\n        if not getattr(self, \"name\", None):\n            self.name = \"Inconnu\"\n        self.avatar = DEFAULT_AVATAR\n</code></pre>"},{"location":"architecture/models/#website.models.User.refresh_roles","title":"<code>refresh_roles()</code>","text":"<p>Refresh role info from Discord (cached for 5 minutes).</p> Source code in <code>website/models/user.py</code> <pre><code>def refresh_roles(self):\n    \"\"\"Refresh role info from Discord (cached for 5 minutes).\"\"\"\n    try:\n        roles = get_user_roles(self.id)\n        self.is_gm = current_app.config[\"DISCORD_GM_ROLE_ID\"] in roles\n        self.is_admin = current_app.config[\"DISCORD_ADMIN_ROLE_ID\"] in roles\n        self.is_player = current_app.config[\"DISCORD_PLAYER_ROLE_ID\"] in roles\n    except Exception:\n        self.is_gm = False\n        self.is_admin = False\n        self.is_player = False\n</code></pre>"},{"location":"architecture/models/#website.models.User.to_dict","title":"<code>to_dict(include_relationships=False)</code>","text":"<p>Serialize the User instance into a Python dict.</p> <p>Includes dynamic attributes (avatar, roles) not stored in the database.</p> Source code in <code>website/models/user.py</code> <pre><code>def to_dict(self, include_relationships=False):\n    \"\"\"Serialize the User instance into a Python dict.\n\n    Includes dynamic attributes (avatar, roles) not stored in the database.\n    \"\"\"\n    data = {\n        \"id\": self.id,\n        \"name\": self.name,\n        \"username\": self.username,\n        \"not_player_as_of\": (\n            self.not_player_as_of.isoformat() if self.not_player_as_of else None\n        ),\n        \"avatar\": getattr(self, \"avatar\", DEFAULT_AVATAR),\n        \"is_gm\": getattr(self, \"is_gm\", False),\n        \"is_admin\": getattr(self, \"is_admin\", False),\n        \"is_player\": getattr(self, \"is_player\", False),\n    }\n\n    if include_relationships:\n        self._add_relationships_to_dict(data)\n\n    return data\n</code></pre>"},{"location":"architecture/models/#website.models.User.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a User object from a dictionary.</p> <p>Expected keys: 'id' (required), 'name' (optional). Additional keys (avatar/is_gm/is_admin/is_player) will be set as attributes on the created instance if present.</p> Source code in <code>website/models/user.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict):\n    \"\"\"Create a User object from a dictionary.\n\n    Expected keys: 'id' (required), 'name' (optional).\n    Additional keys (avatar/is_gm/is_admin/is_player) will be set as attributes\n    on the created instance if present.\n    \"\"\"\n    if \"id\" not in data:\n        raise ValidationError(\"Missing id when creating User from dict.\", field=\"id\")\n    user = cls(\n        id=str(data[\"id\"]),\n        name=data.get(\"name\", \"Inconnu\"),\n        username=data.get(\"username\"),\n    )\n\n    # Optional attrs that are convenient to set from API payloads\n    if \"avatar\" in data:\n        user.avatar = data[\"avatar\"]\n    if \"is_gm\" in data:\n        user.is_gm = bool(data[\"is_gm\"])\n    if \"is_admin\" in data:\n        user.is_admin = bool(data[\"is_admin\"])\n    if \"is_player\" in data:\n        user.is_player = bool(data[\"is_player\"])\n    if \"not_player_as_of\" in data:\n        value = data[\"not_player_as_of\"]\n        if isinstance(value, str):\n            user.not_player_as_of = datetime.fromisoformat(value)\n        else:\n            user.not_player_as_of = value\n\n    return user\n</code></pre>"},{"location":"architecture/models/#website.models.User.from_json","title":"<code>from_json(data)</code>  <code>classmethod</code>","text":"<p>Alias for from_dict() for API compatibility.</p> Source code in <code>website/models/user.py</code> <pre><code>@classmethod\ndef from_json(cls, data):\n    \"\"\"Alias for from_dict() for API compatibility.\"\"\"\n    return cls.from_dict(data)\n</code></pre>"},{"location":"architecture/models/#website.models.User.update_from_dict","title":"<code>update_from_dict(data)</code>","text":"<p>Update the user from a dictionary of fields.</p> Source code in <code>website/models/user.py</code> <pre><code>def update_from_dict(self, data: dict):\n    \"\"\"Update the user from a dictionary of fields.\"\"\"\n    for field in [\"name\", \"username\", \"not_player_as_of\"]:\n        if field in data:\n            setattr(self, field, data[field])\n</code></pre>"},{"location":"architecture/models/#website.models.Vtt","title":"<code>Vtt</code>","text":"<p>               Bases: <code>Model</code>, <code>SerializableMixin</code></p> <p>A virtual tabletop platform (e.g. Foundry VTT, Roll20).</p> <p>Attributes:</p> Name Type Description <code>id</code> <p>Primary key.</p> <code>name</code> <p>Unique VTT name.</p> <code>icon</code> <p>Path or URL to the VTT icon.</p> Source code in <code>website/models/vtt.py</code> <pre><code>class Vtt(db.Model, SerializableMixin):\n    \"\"\"A virtual tabletop platform (e.g. Foundry VTT, Roll20).\n\n    Attributes:\n        id: Primary key.\n        name: Unique VTT name.\n        icon: Path or URL to the VTT icon.\n    \"\"\"\n\n    __tablename__ = \"vtt\"\n\n    _exclude_fields = []\n    _relationship_fields = [\"games_vtt\"]\n\n    id = db.Column(db.BigInteger, primary_key=True)\n    name = db.Column(db.String(), nullable=False, unique=True)\n    icon = db.Column(db.String(), nullable=True)\n\n    games_vtt = db.relationship(\"Game\", backref=\"vtt\")\n\n    @staticmethod\n    def get_vtts():\n        \"\"\"Return a list of all Vtts, ordered by name.\"\"\"\n        return Vtt.query.order_by(\"name\").all()\n\n    @classmethod\n    def from_dict(cls, data):\n        \"\"\"Create a Vtt instance from a Python dict.\"\"\"\n        return cls(\n            id=data.get(\"id\"),\n            name=data.get(\"name\"),\n            icon=data.get(\"icon\"),\n        )\n\n    def update_from_dict(self, data):\n        \"\"\"Update the Vtt instance from a dict (in place).\"\"\"\n        super().update_from_dict(data)\n        return self\n\n    def __repr__(self):\n        return f\"&lt;Vtt id={self.id} name='{self.name}' icon='{self.icon}'&gt;\"\n\n    def __eq__(self, other):\n        if not isinstance(other, Vtt):\n            return NotImplemented\n        return (self.id, self.name, self.icon) == (other.id, other.name, other.icon)\n</code></pre>"},{"location":"architecture/models/#website.models.Vtt.get_vtts","title":"<code>get_vtts()</code>  <code>staticmethod</code>","text":"<p>Return a list of all Vtts, ordered by name.</p> Source code in <code>website/models/vtt.py</code> <pre><code>@staticmethod\ndef get_vtts():\n    \"\"\"Return a list of all Vtts, ordered by name.\"\"\"\n    return Vtt.query.order_by(\"name\").all()\n</code></pre>"},{"location":"architecture/models/#website.models.Vtt.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a Vtt instance from a Python dict.</p> Source code in <code>website/models/vtt.py</code> <pre><code>@classmethod\ndef from_dict(cls, data):\n    \"\"\"Create a Vtt instance from a Python dict.\"\"\"\n    return cls(\n        id=data.get(\"id\"),\n        name=data.get(\"name\"),\n        icon=data.get(\"icon\"),\n    )\n</code></pre>"},{"location":"architecture/models/#website.models.Vtt.update_from_dict","title":"<code>update_from_dict(data)</code>","text":"<p>Update the Vtt instance from a dict (in place).</p> Source code in <code>website/models/vtt.py</code> <pre><code>def update_from_dict(self, data):\n    \"\"\"Update the Vtt instance from a dict (in place).\"\"\"\n    super().update_from_dict(data)\n    return self\n</code></pre>"},{"location":"architecture/repositories/","title":"Repositories","text":"<p>The repository layer lives in <code>website/repositories/</code> and handles data access only \u2014 queries, CRUD, and database interactions.</p> <p>Repositories:</p> <ul> <li>Never contain business logic or validation</li> <li>Never access Flask context</li> <li>Never commit transactions (services own transaction boundaries)</li> <li>Inherit from a shared <code>BaseRepository</code> for common CRUD operations</li> </ul>"},{"location":"architecture/repositories/#overview","title":"Overview","text":"Repository Model Description <code>BaseRepository</code> \u2014 Generic CRUD operations inherited by all repositories <code>ChannelRepository</code> <code>Channel</code> Discord category management and size tracking <code>GameRepository</code> <code>Game</code> Game queries with filtering, search, pagination, and eager loading <code>GameEventRepository</code> <code>GameEvent</code> Game audit log entry creation <code>GameSessionRepository</code> <code>GameSession</code> Session date range queries and conflict detection <code>SpecialEventRepository</code> <code>SpecialEvent</code> Themed event retrieval with active/inactive filtering <code>SystemRepository</code> <code>System</code> RPG system lookups <code>TrophyRepository</code> <code>Trophy</code>, <code>UserTrophy</code> Achievement data and leaderboard aggregations <code>UserRepository</code> <code>User</code> User entity retrieval <code>VttRepository</code> <code>Vtt</code> Virtual tabletop platform lookups"},{"location":"architecture/repositories/#api-reference","title":"API Reference","text":"<p>Repository layer for data access operations.</p>"},{"location":"architecture/repositories/#website.repositories.BaseRepository","title":"<code>BaseRepository</code>","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Base repository providing common CRUD operations.</p> <p>Repositories never commit \u2014 they only add, flush, and delete. The service layer owns the transaction boundary.</p> Source code in <code>website/repositories/base.py</code> <pre><code>class BaseRepository(Generic[T]):\n    \"\"\"Base repository providing common CRUD operations.\n\n    Repositories never commit \u2014 they only add, flush, and delete.\n    The service layer owns the transaction boundary.\n    \"\"\"\n\n    model_class: type[T]\n\n    def __init__(self, session=None):\n        self.session = session or db.session\n\n    def get_by_id(self, id: int) -&gt; T | None:\n        \"\"\"Retrieve an entity by its primary key.\n\n        Args:\n            id: Primary key value.\n\n        Returns:\n            Entity instance, or None if not found.\n        \"\"\"\n        return self.session.get(self.model_class, id)\n\n    def get_by_id_or_404(self, id: int) -&gt; T:\n        \"\"\"Retrieve an entity by ID or abort with 404.\n\n        Args:\n            id: Primary key value.\n\n        Returns:\n            Entity instance.\n\n        Raises:\n            NotFound: If entity does not exist.\n        \"\"\"\n        return db.get_or_404(self.model_class, id)\n\n    def get_all(self) -&gt; list[T]:\n        \"\"\"Retrieve all entities of this type.\n\n        Returns:\n            List of all entity instances.\n        \"\"\"\n        return self.session.query(self.model_class).all()\n\n    def add(self, entity: T) -&gt; T:\n        \"\"\"Add an entity to the session and flush.\n\n        Args:\n            entity: Entity instance to persist.\n\n        Returns:\n            The persisted entity.\n        \"\"\"\n        self.session.add(entity)\n        self.session.flush()\n        return entity\n\n    def delete(self, entity: T) -&gt; None:\n        \"\"\"Delete an entity from the session and flush.\n\n        Args:\n            entity: Entity instance to remove.\n        \"\"\"\n        self.session.delete(entity)\n        self.session.flush()\n\n    def count(self) -&gt; int:\n        \"\"\"Return the total count of entities.\n\n        Returns:\n            Integer count.\n        \"\"\"\n        return self.session.query(self.model_class).count()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.BaseRepository.get_by_id","title":"<code>get_by_id(id)</code>","text":"<p>Retrieve an entity by its primary key.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Primary key value.</p> required <p>Returns:</p> Type Description <code>T | None</code> <p>Entity instance, or None if not found.</p> Source code in <code>website/repositories/base.py</code> <pre><code>def get_by_id(self, id: int) -&gt; T | None:\n    \"\"\"Retrieve an entity by its primary key.\n\n    Args:\n        id: Primary key value.\n\n    Returns:\n        Entity instance, or None if not found.\n    \"\"\"\n    return self.session.get(self.model_class, id)\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.BaseRepository.get_by_id_or_404","title":"<code>get_by_id_or_404(id)</code>","text":"<p>Retrieve an entity by ID or abort with 404.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Primary key value.</p> required <p>Returns:</p> Type Description <code>T</code> <p>Entity instance.</p> <p>Raises:</p> Type Description <code>NotFound</code> <p>If entity does not exist.</p> Source code in <code>website/repositories/base.py</code> <pre><code>def get_by_id_or_404(self, id: int) -&gt; T:\n    \"\"\"Retrieve an entity by ID or abort with 404.\n\n    Args:\n        id: Primary key value.\n\n    Returns:\n        Entity instance.\n\n    Raises:\n        NotFound: If entity does not exist.\n    \"\"\"\n    return db.get_or_404(self.model_class, id)\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.BaseRepository.get_all","title":"<code>get_all()</code>","text":"<p>Retrieve all entities of this type.</p> <p>Returns:</p> Type Description <code>list[T]</code> <p>List of all entity instances.</p> Source code in <code>website/repositories/base.py</code> <pre><code>def get_all(self) -&gt; list[T]:\n    \"\"\"Retrieve all entities of this type.\n\n    Returns:\n        List of all entity instances.\n    \"\"\"\n    return self.session.query(self.model_class).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.BaseRepository.add","title":"<code>add(entity)</code>","text":"<p>Add an entity to the session and flush.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>T</code> <p>Entity instance to persist.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The persisted entity.</p> Source code in <code>website/repositories/base.py</code> <pre><code>def add(self, entity: T) -&gt; T:\n    \"\"\"Add an entity to the session and flush.\n\n    Args:\n        entity: Entity instance to persist.\n\n    Returns:\n        The persisted entity.\n    \"\"\"\n    self.session.add(entity)\n    self.session.flush()\n    return entity\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.BaseRepository.delete","title":"<code>delete(entity)</code>","text":"<p>Delete an entity from the session and flush.</p> <p>Parameters:</p> Name Type Description Default <code>entity</code> <code>T</code> <p>Entity instance to remove.</p> required Source code in <code>website/repositories/base.py</code> <pre><code>def delete(self, entity: T) -&gt; None:\n    \"\"\"Delete an entity from the session and flush.\n\n    Args:\n        entity: Entity instance to remove.\n    \"\"\"\n    self.session.delete(entity)\n    self.session.flush()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.BaseRepository.count","title":"<code>count()</code>","text":"<p>Return the total count of entities.</p> <p>Returns:</p> Type Description <code>int</code> <p>Integer count.</p> Source code in <code>website/repositories/base.py</code> <pre><code>def count(self) -&gt; int:\n    \"\"\"Return the total count of entities.\n\n    Returns:\n        Integer count.\n    \"\"\"\n    return self.session.query(self.model_class).count()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.ChannelRepository","title":"<code>ChannelRepository</code>","text":"<p>               Bases: <code>BaseRepository[Channel]</code></p> <p>Repository for Channel (Discord category) entities.</p> Source code in <code>website/repositories/channel.py</code> <pre><code>class ChannelRepository(BaseRepository[Channel]):\n    \"\"\"Repository for Channel (Discord category) entities.\"\"\"\n\n    model_class = Channel\n\n    def get_smallest_by_type(self, type: str) -&gt; Channel | None:\n        \"\"\"Find the category with the fewest channels for a game type.\n\n        Args:\n            type: Game type (oneshot or campaign).\n\n        Returns:\n            Channel with smallest size, or None if no match.\n        \"\"\"\n        return self.session.query(Channel).filter_by(type=type).order_by(Channel.size).first()\n\n    def increment_size(self, channel: Channel) -&gt; None:\n        \"\"\"Increment the channel count of a category.\n\n        Args:\n            channel: Channel entity to update.\n        \"\"\"\n        channel.size += 1\n        self.session.flush()\n\n    def decrement_size(self, channel: Channel) -&gt; None:\n        \"\"\"Decrement the channel count of a category (minimum 0).\n\n        Args:\n            channel: Channel entity to update.\n        \"\"\"\n        channel.size = max(0, channel.size - 1)\n        self.session.flush()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.ChannelRepository.get_smallest_by_type","title":"<code>get_smallest_by_type(type)</code>","text":"<p>Find the category with the fewest channels for a game type.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>str</code> <p>Game type (oneshot or campaign).</p> required <p>Returns:</p> Type Description <code>Channel | None</code> <p>Channel with smallest size, or None if no match.</p> Source code in <code>website/repositories/channel.py</code> <pre><code>def get_smallest_by_type(self, type: str) -&gt; Channel | None:\n    \"\"\"Find the category with the fewest channels for a game type.\n\n    Args:\n        type: Game type (oneshot or campaign).\n\n    Returns:\n        Channel with smallest size, or None if no match.\n    \"\"\"\n    return self.session.query(Channel).filter_by(type=type).order_by(Channel.size).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.ChannelRepository.increment_size","title":"<code>increment_size(channel)</code>","text":"<p>Increment the channel count of a category.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Channel entity to update.</p> required Source code in <code>website/repositories/channel.py</code> <pre><code>def increment_size(self, channel: Channel) -&gt; None:\n    \"\"\"Increment the channel count of a category.\n\n    Args:\n        channel: Channel entity to update.\n    \"\"\"\n    channel.size += 1\n    self.session.flush()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.ChannelRepository.decrement_size","title":"<code>decrement_size(channel)</code>","text":"<p>Decrement the channel count of a category (minimum 0).</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Channel entity to update.</p> required Source code in <code>website/repositories/channel.py</code> <pre><code>def decrement_size(self, channel: Channel) -&gt; None:\n    \"\"\"Decrement the channel count of a category (minimum 0).\n\n    Args:\n        channel: Channel entity to update.\n    \"\"\"\n    channel.size = max(0, channel.size - 1)\n    self.session.flush()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository","title":"<code>GameRepository</code>","text":"<p>               Bases: <code>BaseRepository[Game]</code></p> <p>Repository for Game entity.</p> <p>Provides data access methods for games including queries, filtering, and search. All methods return models or None - exceptions for 404s should be raised by services.</p> Source code in <code>website/repositories/game.py</code> <pre><code>class GameRepository(BaseRepository[Game]):\n    \"\"\"Repository for Game entity.\n\n    Provides data access methods for games including queries, filtering, and search.\n    All methods return models or None - exceptions for 404s should be raised by services.\n    \"\"\"\n\n    model_class = Game\n\n    def get_by_slug(self, slug: str) -&gt; Optional[Game]:\n        \"\"\"Get game by slug.\n\n        Args:\n            slug: URL-safe game identifier.\n\n        Returns:\n            Game instance or None if not found.\n        \"\"\"\n        return self.session.query(Game).filter_by(slug=slug).first()\n\n    def get_by_slug_or_404(self, slug: str) -&gt; Game:\n        \"\"\"Get game by slug or raise 404.\n\n        Args:\n            slug: URL-safe game identifier.\n\n        Returns:\n            Game instance.\n\n        Raises:\n            NotFound: If game with slug doesn't exist.\n        \"\"\"\n        return self.session.query(Game).filter_by(slug=slug).first_or_404()\n\n    def get_all_slugs(self) -&gt; set[str]:\n        \"\"\"Get all existing game slugs.\n\n        Returns:\n            Set of all game slugs.\n        \"\"\"\n        return {g.slug for g in self.session.query(Game.slug).all()}\n\n    def find_by_gm(self, gm_id: str) -&gt; list[Game]:\n        \"\"\"Find all games by GM.\n\n        Args:\n            gm_id: GM user ID.\n\n        Returns:\n            List of games GMed by this user.\n        \"\"\"\n        return self.session.query(Game).filter_by(gm_id=gm_id).all()\n\n    def find_by_player(self, player_id: str) -&gt; list[Game]:\n        \"\"\"Find all games where user is a player.\n\n        Args:\n            player_id: Player user ID.\n\n        Returns:\n            List of games where user is registered as player.\n        \"\"\"\n        return self.session.query(Game).join(Game.players).filter(User.id == player_id).all()\n\n    def find_by_special_event(self, event_id: int) -&gt; list[Game]:\n        \"\"\"Find all games for a special event.\n\n        Args:\n            event_id: Special event ID.\n\n        Returns:\n            List of games linked to this special event.\n        \"\"\"\n        return self.session.query(Game).filter_by(special_event_id=event_id).all()\n\n    def query_by_special_event(self, event_id: int):\n        \"\"\"Return a query object for games linked to a special event.\n\n        Unlike ``find_by_special_event`` (which returns a list), this returns\n        an unevaluated query suitable for further filtering and pagination.\n\n        Args:\n            event_id: Special event ID.\n\n        Returns:\n            SQLAlchemy query filtered by special_event_id.\n        \"\"\"\n        return self.session.query(Game).filter(Game.special_event_id == event_id)\n\n    def get_for_update(self, game_id: int) -&gt; Optional[Game]:\n        \"\"\"Get game with pessimistic lock for updates.\n\n        Uses SELECT FOR UPDATE to prevent race conditions during registration.\n\n        Args:\n            game_id: Game ID to lock.\n\n        Returns:\n            Game instance with exclusive lock, or None if not found.\n        \"\"\"\n        return self.session.query(Game).filter_by(id=game_id).with_for_update().first()\n\n    def get_with_relations(self, game_id: int) -&gt; Optional[Game]:\n        \"\"\"Get game with all relationships eagerly loaded.\n\n        Prevents N+1 queries by loading gm, system, vtt, players, and sessions.\n\n        Args:\n            game_id: Game ID.\n\n        Returns:\n            Game instance with relationships loaded, or None if not found.\n        \"\"\"\n        return (\n            self.session.query(Game)\n            .options(\n                joinedload(Game.gm),\n                joinedload(Game.system),\n                joinedload(Game.vtt),\n                subqueryload(Game.players),\n                subqueryload(Game.sessions),\n            )\n            .filter_by(id=game_id)\n            .first()\n        )\n\n    def delete_by_id(self, game_id: int) -&gt; None:\n        \"\"\"Delete game by ID.\n\n        Args:\n            game_id: Game ID to delete.\n        \"\"\"\n        self.session.query(Game).filter_by(id=game_id).delete()\n        self.session.flush()\n\n    def search(\n        self,\n        filters: dict,\n        page: int = 1,\n        per_page: int = 20,\n        user_payload: Optional[dict] = None,\n    ) -&gt; tuple[list[Game], int]:\n        \"\"\"Search games with complex filters and pagination.\n\n        Replaces the complex get_filtered_games logic from helpers.\n\n        Args:\n            filters: Dict containing:\n                - status: List of statuses (open, closed, archived, draft)\n                - game_type: List of types (oneshot, campaign)\n                - restriction: List of restrictions (all, 16+, 18+)\n                - name: Optional name search string\n                - system_id: Optional system ID\n                - vtt_id: Optional VTT ID\n                - gm_id: Optional GM ID (for \"my games\" views)\n                - player_id: Optional player ID (for \"my games as player\" views)\n                - special_event_id: Optional special event ID\n            page: Page number (1-indexed).\n            per_page: Items per page.\n            user_payload: Optional user auth payload for permission filtering.\n\n        Returns:\n            Tuple of (games list, total count).\n        \"\"\"\n        now = datetime.now(timezone.utc)\n        query = self.session.query(Game)\n\n        # Status filter with permission check\n        status = filters.get(\"status\", [\"open\"])\n        if status:\n            status_filters = []\n            for s in status:\n                if s != \"draft\":\n                    status_filters.append(Game.status == s)\n                elif user_payload and user_payload.get(\"is_admin\"):\n                    status_filters.append(Game.status == \"draft\")\n                elif user_payload:\n                    status_filters.append(\n                        and_(\n                            Game.status == \"draft\",\n                            Game.gm_id == user_payload.get(\"user_id\"),\n                        )\n                    )\n            if status_filters:\n                query = query.filter(or_(*status_filters))\n\n        # Type filter\n        game_type = filters.get(\"game_type\", [\"oneshot\", \"campaign\"])\n        if game_type:\n            query = query.filter(Game.type.in_(game_type))\n\n        # Restriction filter\n        restriction = filters.get(\"restriction\", [\"all\", \"16+\", \"18+\"])\n        if restriction:\n            query = query.filter(Game.restriction.in_(restriction))\n\n        # Name search\n        if filters.get(\"name\"):\n            query = query.filter(Game.name.ilike(f\"%{filters['name']}%\"))\n\n        # System filter\n        if filters.get(\"system_id\"):\n            query = query.filter(Game.system_id == filters[\"system_id\"])\n\n        # VTT filter\n        if filters.get(\"vtt_id\"):\n            query = query.filter(Game.vtt_id == filters[\"vtt_id\"])\n\n        # GM filter\n        if filters.get(\"gm_id\"):\n            query = query.filter(Game.gm_id == filters[\"gm_id\"])\n\n        # Player filter\n        if filters.get(\"player_id\"):\n            query = query.join(Game.players).filter(User.id == filters[\"player_id\"])\n\n        # Special event filter\n        if filters.get(\"special_event_id\"):\n            query = query.filter(Game.special_event_id == filters[\"special_event_id\"])\n\n        # Sorting - same logic as original helpers.py\n        status_order = case(\n            (Game.status == \"draft\", 0),\n            (Game.status == \"open\", 1),\n            (Game.status == \"closed\", 2),\n            (Game.status == \"archived\", 3),\n        )\n        is_future = case((Game.date &gt;= now, 0), else_=1)\n        time_distance = func.abs(func.extract(\"epoch\", Game.date - now))\n\n        query = query.order_by(status_order, is_future, time_distance)\n\n        # Get total count before pagination\n        total = query.count()\n\n        # Pagination\n        offset = (page - 1) * per_page\n        games = query.limit(per_page).offset(offset).all()\n\n        return games, total\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.get_by_slug","title":"<code>get_by_slug(slug)</code>","text":"<p>Get game by slug.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL-safe game identifier.</p> required <p>Returns:</p> Type Description <code>Optional[Game]</code> <p>Game instance or None if not found.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def get_by_slug(self, slug: str) -&gt; Optional[Game]:\n    \"\"\"Get game by slug.\n\n    Args:\n        slug: URL-safe game identifier.\n\n    Returns:\n        Game instance or None if not found.\n    \"\"\"\n    return self.session.query(Game).filter_by(slug=slug).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.get_by_slug_or_404","title":"<code>get_by_slug_or_404(slug)</code>","text":"<p>Get game by slug or raise 404.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL-safe game identifier.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>Game instance.</p> <p>Raises:</p> Type Description <code>NotFound</code> <p>If game with slug doesn't exist.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def get_by_slug_or_404(self, slug: str) -&gt; Game:\n    \"\"\"Get game by slug or raise 404.\n\n    Args:\n        slug: URL-safe game identifier.\n\n    Returns:\n        Game instance.\n\n    Raises:\n        NotFound: If game with slug doesn't exist.\n    \"\"\"\n    return self.session.query(Game).filter_by(slug=slug).first_or_404()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.get_all_slugs","title":"<code>get_all_slugs()</code>","text":"<p>Get all existing game slugs.</p> <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of all game slugs.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def get_all_slugs(self) -&gt; set[str]:\n    \"\"\"Get all existing game slugs.\n\n    Returns:\n        Set of all game slugs.\n    \"\"\"\n    return {g.slug for g in self.session.query(Game.slug).all()}\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.find_by_gm","title":"<code>find_by_gm(gm_id)</code>","text":"<p>Find all games by GM.</p> <p>Parameters:</p> Name Type Description Default <code>gm_id</code> <code>str</code> <p>GM user ID.</p> required <p>Returns:</p> Type Description <code>list[Game]</code> <p>List of games GMed by this user.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def find_by_gm(self, gm_id: str) -&gt; list[Game]:\n    \"\"\"Find all games by GM.\n\n    Args:\n        gm_id: GM user ID.\n\n    Returns:\n        List of games GMed by this user.\n    \"\"\"\n    return self.session.query(Game).filter_by(gm_id=gm_id).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.find_by_player","title":"<code>find_by_player(player_id)</code>","text":"<p>Find all games where user is a player.</p> <p>Parameters:</p> Name Type Description Default <code>player_id</code> <code>str</code> <p>Player user ID.</p> required <p>Returns:</p> Type Description <code>list[Game]</code> <p>List of games where user is registered as player.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def find_by_player(self, player_id: str) -&gt; list[Game]:\n    \"\"\"Find all games where user is a player.\n\n    Args:\n        player_id: Player user ID.\n\n    Returns:\n        List of games where user is registered as player.\n    \"\"\"\n    return self.session.query(Game).join(Game.players).filter(User.id == player_id).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.find_by_special_event","title":"<code>find_by_special_event(event_id)</code>","text":"<p>Find all games for a special event.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>int</code> <p>Special event ID.</p> required <p>Returns:</p> Type Description <code>list[Game]</code> <p>List of games linked to this special event.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def find_by_special_event(self, event_id: int) -&gt; list[Game]:\n    \"\"\"Find all games for a special event.\n\n    Args:\n        event_id: Special event ID.\n\n    Returns:\n        List of games linked to this special event.\n    \"\"\"\n    return self.session.query(Game).filter_by(special_event_id=event_id).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.query_by_special_event","title":"<code>query_by_special_event(event_id)</code>","text":"<p>Return a query object for games linked to a special event.</p> <p>Unlike <code>find_by_special_event</code> (which returns a list), this returns an unevaluated query suitable for further filtering and pagination.</p> <p>Parameters:</p> Name Type Description Default <code>event_id</code> <code>int</code> <p>Special event ID.</p> required <p>Returns:</p> Type Description <p>SQLAlchemy query filtered by special_event_id.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def query_by_special_event(self, event_id: int):\n    \"\"\"Return a query object for games linked to a special event.\n\n    Unlike ``find_by_special_event`` (which returns a list), this returns\n    an unevaluated query suitable for further filtering and pagination.\n\n    Args:\n        event_id: Special event ID.\n\n    Returns:\n        SQLAlchemy query filtered by special_event_id.\n    \"\"\"\n    return self.session.query(Game).filter(Game.special_event_id == event_id)\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.get_for_update","title":"<code>get_for_update(game_id)</code>","text":"<p>Get game with pessimistic lock for updates.</p> <p>Uses SELECT FOR UPDATE to prevent race conditions during registration.</p> <p>Parameters:</p> Name Type Description Default <code>game_id</code> <code>int</code> <p>Game ID to lock.</p> required <p>Returns:</p> Type Description <code>Optional[Game]</code> <p>Game instance with exclusive lock, or None if not found.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def get_for_update(self, game_id: int) -&gt; Optional[Game]:\n    \"\"\"Get game with pessimistic lock for updates.\n\n    Uses SELECT FOR UPDATE to prevent race conditions during registration.\n\n    Args:\n        game_id: Game ID to lock.\n\n    Returns:\n        Game instance with exclusive lock, or None if not found.\n    \"\"\"\n    return self.session.query(Game).filter_by(id=game_id).with_for_update().first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.get_with_relations","title":"<code>get_with_relations(game_id)</code>","text":"<p>Get game with all relationships eagerly loaded.</p> <p>Prevents N+1 queries by loading gm, system, vtt, players, and sessions.</p> <p>Parameters:</p> Name Type Description Default <code>game_id</code> <code>int</code> <p>Game ID.</p> required <p>Returns:</p> Type Description <code>Optional[Game]</code> <p>Game instance with relationships loaded, or None if not found.</p> Source code in <code>website/repositories/game.py</code> <pre><code>def get_with_relations(self, game_id: int) -&gt; Optional[Game]:\n    \"\"\"Get game with all relationships eagerly loaded.\n\n    Prevents N+1 queries by loading gm, system, vtt, players, and sessions.\n\n    Args:\n        game_id: Game ID.\n\n    Returns:\n        Game instance with relationships loaded, or None if not found.\n    \"\"\"\n    return (\n        self.session.query(Game)\n        .options(\n            joinedload(Game.gm),\n            joinedload(Game.system),\n            joinedload(Game.vtt),\n            subqueryload(Game.players),\n            subqueryload(Game.sessions),\n        )\n        .filter_by(id=game_id)\n        .first()\n    )\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.delete_by_id","title":"<code>delete_by_id(game_id)</code>","text":"<p>Delete game by ID.</p> <p>Parameters:</p> Name Type Description Default <code>game_id</code> <code>int</code> <p>Game ID to delete.</p> required Source code in <code>website/repositories/game.py</code> <pre><code>def delete_by_id(self, game_id: int) -&gt; None:\n    \"\"\"Delete game by ID.\n\n    Args:\n        game_id: Game ID to delete.\n    \"\"\"\n    self.session.query(Game).filter_by(id=game_id).delete()\n    self.session.flush()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameRepository.search","title":"<code>search(filters, page=1, per_page=20, user_payload=None)</code>","text":"<p>Search games with complex filters and pagination.</p> <p>Replaces the complex get_filtered_games logic from helpers.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>dict</code> <p>Dict containing: - status: List of statuses (open, closed, archived, draft) - game_type: List of types (oneshot, campaign) - restriction: List of restrictions (all, 16+, 18+) - name: Optional name search string - system_id: Optional system ID - vtt_id: Optional VTT ID - gm_id: Optional GM ID (for \"my games\" views) - player_id: Optional player ID (for \"my games as player\" views) - special_event_id: Optional special event ID</p> required <code>page</code> <code>int</code> <p>Page number (1-indexed).</p> <code>1</code> <code>per_page</code> <code>int</code> <p>Items per page.</p> <code>20</code> <code>user_payload</code> <code>Optional[dict]</code> <p>Optional user auth payload for permission filtering.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[Game], int]</code> <p>Tuple of (games list, total count).</p> Source code in <code>website/repositories/game.py</code> <pre><code>def search(\n    self,\n    filters: dict,\n    page: int = 1,\n    per_page: int = 20,\n    user_payload: Optional[dict] = None,\n) -&gt; tuple[list[Game], int]:\n    \"\"\"Search games with complex filters and pagination.\n\n    Replaces the complex get_filtered_games logic from helpers.\n\n    Args:\n        filters: Dict containing:\n            - status: List of statuses (open, closed, archived, draft)\n            - game_type: List of types (oneshot, campaign)\n            - restriction: List of restrictions (all, 16+, 18+)\n            - name: Optional name search string\n            - system_id: Optional system ID\n            - vtt_id: Optional VTT ID\n            - gm_id: Optional GM ID (for \"my games\" views)\n            - player_id: Optional player ID (for \"my games as player\" views)\n            - special_event_id: Optional special event ID\n        page: Page number (1-indexed).\n        per_page: Items per page.\n        user_payload: Optional user auth payload for permission filtering.\n\n    Returns:\n        Tuple of (games list, total count).\n    \"\"\"\n    now = datetime.now(timezone.utc)\n    query = self.session.query(Game)\n\n    # Status filter with permission check\n    status = filters.get(\"status\", [\"open\"])\n    if status:\n        status_filters = []\n        for s in status:\n            if s != \"draft\":\n                status_filters.append(Game.status == s)\n            elif user_payload and user_payload.get(\"is_admin\"):\n                status_filters.append(Game.status == \"draft\")\n            elif user_payload:\n                status_filters.append(\n                    and_(\n                        Game.status == \"draft\",\n                        Game.gm_id == user_payload.get(\"user_id\"),\n                    )\n                )\n        if status_filters:\n            query = query.filter(or_(*status_filters))\n\n    # Type filter\n    game_type = filters.get(\"game_type\", [\"oneshot\", \"campaign\"])\n    if game_type:\n        query = query.filter(Game.type.in_(game_type))\n\n    # Restriction filter\n    restriction = filters.get(\"restriction\", [\"all\", \"16+\", \"18+\"])\n    if restriction:\n        query = query.filter(Game.restriction.in_(restriction))\n\n    # Name search\n    if filters.get(\"name\"):\n        query = query.filter(Game.name.ilike(f\"%{filters['name']}%\"))\n\n    # System filter\n    if filters.get(\"system_id\"):\n        query = query.filter(Game.system_id == filters[\"system_id\"])\n\n    # VTT filter\n    if filters.get(\"vtt_id\"):\n        query = query.filter(Game.vtt_id == filters[\"vtt_id\"])\n\n    # GM filter\n    if filters.get(\"gm_id\"):\n        query = query.filter(Game.gm_id == filters[\"gm_id\"])\n\n    # Player filter\n    if filters.get(\"player_id\"):\n        query = query.join(Game.players).filter(User.id == filters[\"player_id\"])\n\n    # Special event filter\n    if filters.get(\"special_event_id\"):\n        query = query.filter(Game.special_event_id == filters[\"special_event_id\"])\n\n    # Sorting - same logic as original helpers.py\n    status_order = case(\n        (Game.status == \"draft\", 0),\n        (Game.status == \"open\", 1),\n        (Game.status == \"closed\", 2),\n        (Game.status == \"archived\", 3),\n    )\n    is_future = case((Game.date &gt;= now, 0), else_=1)\n    time_distance = func.abs(func.extract(\"epoch\", Game.date - now))\n\n    query = query.order_by(status_order, is_future, time_distance)\n\n    # Get total count before pagination\n    total = query.count()\n\n    # Pagination\n    offset = (page - 1) * per_page\n    games = query.limit(per_page).offset(offset).all()\n\n    return games, total\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameEventRepository","title":"<code>GameEventRepository</code>","text":"<p>               Bases: <code>BaseRepository[GameEvent]</code></p> <p>Repository for GameEvent entities.</p> Source code in <code>website/repositories/game_event.py</code> <pre><code>class GameEventRepository(BaseRepository[GameEvent]):\n    \"\"\"Repository for GameEvent entities.\"\"\"\n\n    model_class = GameEvent\n\n    def log(\n        self, action: str, game_id: int, description: str | None = None, user_id: str | None = None\n    ) -&gt; GameEvent:\n        \"\"\"Create and persist a new game event.\n\n        Args:\n            action: Event action type.\n            game_id: ID of the related game.\n            description: Optional event description.\n            user_id: Optional ID of the user that performed the action.\n\n        Returns:\n            Created GameEvent instance.\n        \"\"\"\n        event = GameEvent(action=action, game_id=game_id, description=description, user_id=user_id)\n        return self.add(event)\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameEventRepository.log","title":"<code>log(action, game_id, description=None, user_id=None)</code>","text":"<p>Create and persist a new game event.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>Event action type.</p> required <code>game_id</code> <code>int</code> <p>ID of the related game.</p> required <code>description</code> <code>str | None</code> <p>Optional event description.</p> <code>None</code> <code>user_id</code> <code>str | None</code> <p>Optional ID of the user that performed the action.</p> <code>None</code> <p>Returns:</p> Type Description <code>GameEvent</code> <p>Created GameEvent instance.</p> Source code in <code>website/repositories/game_event.py</code> <pre><code>def log(\n    self, action: str, game_id: int, description: str | None = None, user_id: str | None = None\n) -&gt; GameEvent:\n    \"\"\"Create and persist a new game event.\n\n    Args:\n        action: Event action type.\n        game_id: ID of the related game.\n        description: Optional event description.\n        user_id: Optional ID of the user that performed the action.\n\n    Returns:\n        Created GameEvent instance.\n    \"\"\"\n    event = GameEvent(action=action, game_id=game_id, description=description, user_id=user_id)\n    return self.add(event)\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameSessionRepository","title":"<code>GameSessionRepository</code>","text":"<p>               Bases: <code>BaseRepository[GameSession]</code></p> <p>Repository for GameSession entities.</p> Source code in <code>website/repositories/game_session.py</code> <pre><code>class GameSessionRepository(BaseRepository[GameSession]):\n    \"\"\"Repository for GameSession entities.\"\"\"\n\n    model_class = GameSession\n\n    def find_in_range(self, start: datetime, end: datetime) -&gt; list[GameSession]:\n        \"\"\"Find all sessions within a date range.\n\n        Args:\n            start: Range start datetime (inclusive).\n            end: Range end datetime (inclusive).\n\n        Returns:\n            List of GameSession instances within the range.\n        \"\"\"\n        return (\n            self.session.query(GameSession)\n            .filter(GameSession.start &gt;= start, GameSession.end &lt;= end)\n            .all()\n        )\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.GameSessionRepository.find_in_range","title":"<code>find_in_range(start, end)</code>","text":"<p>Find all sessions within a date range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Range start datetime (inclusive).</p> required <code>end</code> <code>datetime</code> <p>Range end datetime (inclusive).</p> required <p>Returns:</p> Type Description <code>list[GameSession]</code> <p>List of GameSession instances within the range.</p> Source code in <code>website/repositories/game_session.py</code> <pre><code>def find_in_range(self, start: datetime, end: datetime) -&gt; list[GameSession]:\n    \"\"\"Find all sessions within a date range.\n\n    Args:\n        start: Range start datetime (inclusive).\n        end: Range end datetime (inclusive).\n\n    Returns:\n        List of GameSession instances within the range.\n    \"\"\"\n    return (\n        self.session.query(GameSession)\n        .filter(GameSession.start &gt;= start, GameSession.end &lt;= end)\n        .all()\n    )\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SpecialEventRepository","title":"<code>SpecialEventRepository</code>","text":"<p>               Bases: <code>BaseRepository[SpecialEvent]</code></p> <p>Repository for SpecialEvent data access.</p> <p>Handles querying special events with optional filtering by active status.</p> Source code in <code>website/repositories/special_event.py</code> <pre><code>class SpecialEventRepository(BaseRepository[SpecialEvent]):\n    \"\"\"Repository for SpecialEvent data access.\n\n    Handles querying special events with optional filtering by active status.\n    \"\"\"\n\n    model_class = SpecialEvent\n\n    def get_all(self, active_only: bool = False) -&gt; list[SpecialEvent]:\n        \"\"\"Get all special events, optionally filtered by active status.\n\n        Args:\n            active_only: If True, only return active events. Defaults to False.\n\n        Returns:\n            List of SpecialEvent instances ordered by name.\n        \"\"\"\n        query = self.session.query(SpecialEvent).order_by(SpecialEvent.name)\n        if active_only:\n            query = query.filter_by(active=True)\n        return query.all()\n\n    def get_active(self) -&gt; list[SpecialEvent]:\n        \"\"\"Get all active special events.\n\n        Convenience method for getting active events only.\n\n        Returns:\n            List of active SpecialEvent instances ordered by name.\n        \"\"\"\n        return self.get_all(active_only=True)\n\n    def get_by_name(self, name: str) -&gt; SpecialEvent | None:\n        \"\"\"Get special event by name.\n\n        Args:\n            name: Name of the special event.\n\n        Returns:\n            SpecialEvent instance if found, None otherwise.\n        \"\"\"\n        return self.session.query(SpecialEvent).filter_by(name=name).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SpecialEventRepository.get_all","title":"<code>get_all(active_only=False)</code>","text":"<p>Get all special events, optionally filtered by active status.</p> <p>Parameters:</p> Name Type Description Default <code>active_only</code> <code>bool</code> <p>If True, only return active events. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[SpecialEvent]</code> <p>List of SpecialEvent instances ordered by name.</p> Source code in <code>website/repositories/special_event.py</code> <pre><code>def get_all(self, active_only: bool = False) -&gt; list[SpecialEvent]:\n    \"\"\"Get all special events, optionally filtered by active status.\n\n    Args:\n        active_only: If True, only return active events. Defaults to False.\n\n    Returns:\n        List of SpecialEvent instances ordered by name.\n    \"\"\"\n    query = self.session.query(SpecialEvent).order_by(SpecialEvent.name)\n    if active_only:\n        query = query.filter_by(active=True)\n    return query.all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SpecialEventRepository.get_active","title":"<code>get_active()</code>","text":"<p>Get all active special events.</p> <p>Convenience method for getting active events only.</p> <p>Returns:</p> Type Description <code>list[SpecialEvent]</code> <p>List of active SpecialEvent instances ordered by name.</p> Source code in <code>website/repositories/special_event.py</code> <pre><code>def get_active(self) -&gt; list[SpecialEvent]:\n    \"\"\"Get all active special events.\n\n    Convenience method for getting active events only.\n\n    Returns:\n        List of active SpecialEvent instances ordered by name.\n    \"\"\"\n    return self.get_all(active_only=True)\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SpecialEventRepository.get_by_name","title":"<code>get_by_name(name)</code>","text":"<p>Get special event by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the special event.</p> required <p>Returns:</p> Type Description <code>SpecialEvent | None</code> <p>SpecialEvent instance if found, None otherwise.</p> Source code in <code>website/repositories/special_event.py</code> <pre><code>def get_by_name(self, name: str) -&gt; SpecialEvent | None:\n    \"\"\"Get special event by name.\n\n    Args:\n        name: Name of the special event.\n\n    Returns:\n        SpecialEvent instance if found, None otherwise.\n    \"\"\"\n    return self.session.query(SpecialEvent).filter_by(name=name).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SystemRepository","title":"<code>SystemRepository</code>","text":"<p>               Bases: <code>BaseRepository[System]</code></p> <p>Repository for System entities.</p> Source code in <code>website/repositories/system.py</code> <pre><code>class SystemRepository(BaseRepository[System]):\n    \"\"\"Repository for System entities.\"\"\"\n\n    model_class = System\n\n    def get_all_ordered(self) -&gt; list[System]:\n        \"\"\"Retrieve all systems ordered by name.\n\n        Returns:\n            List of System instances sorted alphabetically.\n        \"\"\"\n        return self.session.query(System).order_by(System.name).all()\n\n    def get_by_name(self, name: str) -&gt; System | None:\n        \"\"\"Find a system by its name.\n\n        Args:\n            name: System name to search for.\n\n        Returns:\n            System instance if found, None otherwise.\n        \"\"\"\n        return self.session.query(System).filter_by(name=name).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SystemRepository.get_all_ordered","title":"<code>get_all_ordered()</code>","text":"<p>Retrieve all systems ordered by name.</p> <p>Returns:</p> Type Description <code>list[System]</code> <p>List of System instances sorted alphabetically.</p> Source code in <code>website/repositories/system.py</code> <pre><code>def get_all_ordered(self) -&gt; list[System]:\n    \"\"\"Retrieve all systems ordered by name.\n\n    Returns:\n        List of System instances sorted alphabetically.\n    \"\"\"\n    return self.session.query(System).order_by(System.name).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.SystemRepository.get_by_name","title":"<code>get_by_name(name)</code>","text":"<p>Find a system by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>System name to search for.</p> required <p>Returns:</p> Type Description <code>System | None</code> <p>System instance if found, None otherwise.</p> Source code in <code>website/repositories/system.py</code> <pre><code>def get_by_name(self, name: str) -&gt; System | None:\n    \"\"\"Find a system by its name.\n\n    Args:\n        name: System name to search for.\n\n    Returns:\n        System instance if found, None otherwise.\n    \"\"\"\n    return self.session.query(System).filter_by(name=name).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.TrophyRepository","title":"<code>TrophyRepository</code>","text":"<p>               Bases: <code>BaseRepository[Trophy]</code></p> <p>Repository for Trophy data access.</p> <p>Handles querying trophies, user trophies, and leaderboard aggregations.</p> Source code in <code>website/repositories/trophy.py</code> <pre><code>class TrophyRepository(BaseRepository[Trophy]):\n    \"\"\"Repository for Trophy data access.\n\n    Handles querying trophies, user trophies, and leaderboard aggregations.\n    \"\"\"\n\n    model_class = Trophy\n\n    def get_user_trophy(self, user_id: str, trophy_id: int) -&gt; UserTrophy | None:\n        \"\"\"Get a user's trophy record.\n\n        Args:\n            user_id: User ID.\n            trophy_id: Trophy ID.\n\n        Returns:\n            UserTrophy instance if user has this trophy, None otherwise.\n        \"\"\"\n        return (\n            self.session.query(UserTrophy).filter_by(user_id=user_id, trophy_id=trophy_id).first()\n        )\n\n    def award_trophy(self, user_id: str, trophy_id: int, amount: int = 1) -&gt; UserTrophy:\n        \"\"\"Create or update a user trophy record.\n\n        Args:\n            user_id: User ID.\n            trophy_id: Trophy ID.\n            amount: Quantity to add. Defaults to 1.\n\n        Returns:\n            Created or updated UserTrophy instance.\n        \"\"\"\n        user_trophy = self.get_user_trophy(user_id, trophy_id)\n\n        if user_trophy:\n            user_trophy.quantity += amount\n        else:\n            user_trophy = UserTrophy(user_id=user_id, trophy_id=trophy_id, quantity=amount)\n            self.session.add(user_trophy)\n\n        self.session.flush()\n        return user_trophy\n\n    def get_leaderboard(self, trophy_id: int, limit: int = 10) -&gt; list[tuple[User, int]]:\n        \"\"\"Get leaderboard for a specific trophy.\n\n        Args:\n            trophy_id: Trophy ID to get leaderboard for.\n            limit: Maximum number of entries to return. Defaults to 10.\n\n        Returns:\n            List of (User, total_quantity) tuples ordered by quantity descending.\n        \"\"\"\n        return (\n            self.session.query(User, func.sum(UserTrophy.quantity).label(\"total\"))\n            .join(UserTrophy)\n            .filter(UserTrophy.trophy_id == trophy_id)\n            .group_by(User.id)\n            .order_by(func.sum(UserTrophy.quantity).desc())\n            .limit(limit)\n            .all()\n        )\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.TrophyRepository.get_user_trophy","title":"<code>get_user_trophy(user_id, trophy_id)</code>","text":"<p>Get a user's trophy record.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID.</p> required <code>trophy_id</code> <code>int</code> <p>Trophy ID.</p> required <p>Returns:</p> Type Description <code>UserTrophy | None</code> <p>UserTrophy instance if user has this trophy, None otherwise.</p> Source code in <code>website/repositories/trophy.py</code> <pre><code>def get_user_trophy(self, user_id: str, trophy_id: int) -&gt; UserTrophy | None:\n    \"\"\"Get a user's trophy record.\n\n    Args:\n        user_id: User ID.\n        trophy_id: Trophy ID.\n\n    Returns:\n        UserTrophy instance if user has this trophy, None otherwise.\n    \"\"\"\n    return (\n        self.session.query(UserTrophy).filter_by(user_id=user_id, trophy_id=trophy_id).first()\n    )\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.TrophyRepository.award_trophy","title":"<code>award_trophy(user_id, trophy_id, amount=1)</code>","text":"<p>Create or update a user trophy record.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID.</p> required <code>trophy_id</code> <code>int</code> <p>Trophy ID.</p> required <code>amount</code> <code>int</code> <p>Quantity to add. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>UserTrophy</code> <p>Created or updated UserTrophy instance.</p> Source code in <code>website/repositories/trophy.py</code> <pre><code>def award_trophy(self, user_id: str, trophy_id: int, amount: int = 1) -&gt; UserTrophy:\n    \"\"\"Create or update a user trophy record.\n\n    Args:\n        user_id: User ID.\n        trophy_id: Trophy ID.\n        amount: Quantity to add. Defaults to 1.\n\n    Returns:\n        Created or updated UserTrophy instance.\n    \"\"\"\n    user_trophy = self.get_user_trophy(user_id, trophy_id)\n\n    if user_trophy:\n        user_trophy.quantity += amount\n    else:\n        user_trophy = UserTrophy(user_id=user_id, trophy_id=trophy_id, quantity=amount)\n        self.session.add(user_trophy)\n\n    self.session.flush()\n    return user_trophy\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.TrophyRepository.get_leaderboard","title":"<code>get_leaderboard(trophy_id, limit=10)</code>","text":"<p>Get leaderboard for a specific trophy.</p> <p>Parameters:</p> Name Type Description Default <code>trophy_id</code> <code>int</code> <p>Trophy ID to get leaderboard for.</p> required <code>limit</code> <code>int</code> <p>Maximum number of entries to return. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[tuple[User, int]]</code> <p>List of (User, total_quantity) tuples ordered by quantity descending.</p> Source code in <code>website/repositories/trophy.py</code> <pre><code>def get_leaderboard(self, trophy_id: int, limit: int = 10) -&gt; list[tuple[User, int]]:\n    \"\"\"Get leaderboard for a specific trophy.\n\n    Args:\n        trophy_id: Trophy ID to get leaderboard for.\n        limit: Maximum number of entries to return. Defaults to 10.\n\n    Returns:\n        List of (User, total_quantity) tuples ordered by quantity descending.\n    \"\"\"\n    return (\n        self.session.query(User, func.sum(UserTrophy.quantity).label(\"total\"))\n        .join(UserTrophy)\n        .filter(UserTrophy.trophy_id == trophy_id)\n        .group_by(User.id)\n        .order_by(func.sum(UserTrophy.quantity).desc())\n        .limit(limit)\n        .all()\n    )\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.UserRepository","title":"<code>UserRepository</code>","text":"<p>               Bases: <code>BaseRepository[User]</code></p> <p>Repository for User entities.</p> Source code in <code>website/repositories/user.py</code> <pre><code>class UserRepository(BaseRepository[User]):\n    \"\"\"Repository for User entities.\"\"\"\n\n    model_class = User\n\n    def get_active_users(self) -&gt; list[User]:\n        \"\"\"Retrieve all users not marked as inactive.\n\n        Returns:\n            List of User instances where not_player_as_of is NULL.\n        \"\"\"\n        return self.session.query(User).filter(User.not_player_as_of.is_(None)).all()\n\n    def get_active_user_ids(self) -&gt; list[str]:\n        \"\"\"Retrieve IDs of all users not marked as inactive.\n\n        Uses a scalar query to avoid loading full ORM objects\n        (and triggering init_on_load).\n\n        Returns:\n            List of user ID strings where not_player_as_of is NULL.\n        \"\"\"\n        rows = self.session.query(User.id).filter(User.not_player_as_of.is_(None)).all()\n        return [row[0] for row in rows]\n\n    def get_inactive_user_ids(self) -&gt; list[str]:\n        \"\"\"Retrieve IDs of all users marked as inactive.\n\n        Uses a scalar query to avoid loading full ORM objects\n        (and triggering init_on_load).\n\n        Returns:\n            List of user ID strings where not_player_as_of is set.\n        \"\"\"\n        rows = self.session.query(User.id).filter(User.not_player_as_of.isnot(None)).all()\n        return [row[0] for row in rows]\n\n    def get_by_ids(self, ids: list[str]) -&gt; list[User]:\n        \"\"\"Retrieve users by a list of IDs.\n\n        Args:\n            ids: List of user ID strings.\n\n        Returns:\n            List of User instances matching the given IDs.\n        \"\"\"\n        if not ids:\n            return []\n        return self.session.query(User).filter(User.id.in_(ids)).all()\n\n    def get_inactive_users(self) -&gt; list[User]:\n        \"\"\"Retrieve all users marked as inactive.\n\n        Returns:\n            List of User instances where not_player_as_of is set.\n        \"\"\"\n        return self.session.query(User).filter(User.not_player_as_of.isnot(None)).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.UserRepository.get_active_users","title":"<code>get_active_users()</code>","text":"<p>Retrieve all users not marked as inactive.</p> <p>Returns:</p> Type Description <code>list[User]</code> <p>List of User instances where not_player_as_of is NULL.</p> Source code in <code>website/repositories/user.py</code> <pre><code>def get_active_users(self) -&gt; list[User]:\n    \"\"\"Retrieve all users not marked as inactive.\n\n    Returns:\n        List of User instances where not_player_as_of is NULL.\n    \"\"\"\n    return self.session.query(User).filter(User.not_player_as_of.is_(None)).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.UserRepository.get_active_user_ids","title":"<code>get_active_user_ids()</code>","text":"<p>Retrieve IDs of all users not marked as inactive.</p> <p>Uses a scalar query to avoid loading full ORM objects (and triggering init_on_load).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of user ID strings where not_player_as_of is NULL.</p> Source code in <code>website/repositories/user.py</code> <pre><code>def get_active_user_ids(self) -&gt; list[str]:\n    \"\"\"Retrieve IDs of all users not marked as inactive.\n\n    Uses a scalar query to avoid loading full ORM objects\n    (and triggering init_on_load).\n\n    Returns:\n        List of user ID strings where not_player_as_of is NULL.\n    \"\"\"\n    rows = self.session.query(User.id).filter(User.not_player_as_of.is_(None)).all()\n    return [row[0] for row in rows]\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.UserRepository.get_inactive_user_ids","title":"<code>get_inactive_user_ids()</code>","text":"<p>Retrieve IDs of all users marked as inactive.</p> <p>Uses a scalar query to avoid loading full ORM objects (and triggering init_on_load).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of user ID strings where not_player_as_of is set.</p> Source code in <code>website/repositories/user.py</code> <pre><code>def get_inactive_user_ids(self) -&gt; list[str]:\n    \"\"\"Retrieve IDs of all users marked as inactive.\n\n    Uses a scalar query to avoid loading full ORM objects\n    (and triggering init_on_load).\n\n    Returns:\n        List of user ID strings where not_player_as_of is set.\n    \"\"\"\n    rows = self.session.query(User.id).filter(User.not_player_as_of.isnot(None)).all()\n    return [row[0] for row in rows]\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.UserRepository.get_by_ids","title":"<code>get_by_ids(ids)</code>","text":"<p>Retrieve users by a list of IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of user ID strings.</p> required <p>Returns:</p> Type Description <code>list[User]</code> <p>List of User instances matching the given IDs.</p> Source code in <code>website/repositories/user.py</code> <pre><code>def get_by_ids(self, ids: list[str]) -&gt; list[User]:\n    \"\"\"Retrieve users by a list of IDs.\n\n    Args:\n        ids: List of user ID strings.\n\n    Returns:\n        List of User instances matching the given IDs.\n    \"\"\"\n    if not ids:\n        return []\n    return self.session.query(User).filter(User.id.in_(ids)).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.UserRepository.get_inactive_users","title":"<code>get_inactive_users()</code>","text":"<p>Retrieve all users marked as inactive.</p> <p>Returns:</p> Type Description <code>list[User]</code> <p>List of User instances where not_player_as_of is set.</p> Source code in <code>website/repositories/user.py</code> <pre><code>def get_inactive_users(self) -&gt; list[User]:\n    \"\"\"Retrieve all users marked as inactive.\n\n    Returns:\n        List of User instances where not_player_as_of is set.\n    \"\"\"\n    return self.session.query(User).filter(User.not_player_as_of.isnot(None)).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.VttRepository","title":"<code>VttRepository</code>","text":"<p>               Bases: <code>BaseRepository[Vtt]</code></p> <p>Repository for Vtt entities.</p> Source code in <code>website/repositories/vtt.py</code> <pre><code>class VttRepository(BaseRepository[Vtt]):\n    \"\"\"Repository for Vtt entities.\"\"\"\n\n    model_class = Vtt\n\n    def get_all_ordered(self) -&gt; list[Vtt]:\n        \"\"\"Retrieve all VTTs ordered by name.\n\n        Returns:\n            List of Vtt instances sorted alphabetically.\n        \"\"\"\n        return self.session.query(Vtt).order_by(Vtt.name).all()\n\n    def get_by_name(self, name: str) -&gt; Vtt | None:\n        \"\"\"Find a VTT by its name.\n\n        Args:\n            name: VTT name to search for.\n\n        Returns:\n            Vtt instance if found, None otherwise.\n        \"\"\"\n        return self.session.query(Vtt).filter_by(name=name).first()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.VttRepository.get_all_ordered","title":"<code>get_all_ordered()</code>","text":"<p>Retrieve all VTTs ordered by name.</p> <p>Returns:</p> Type Description <code>list[Vtt]</code> <p>List of Vtt instances sorted alphabetically.</p> Source code in <code>website/repositories/vtt.py</code> <pre><code>def get_all_ordered(self) -&gt; list[Vtt]:\n    \"\"\"Retrieve all VTTs ordered by name.\n\n    Returns:\n        List of Vtt instances sorted alphabetically.\n    \"\"\"\n    return self.session.query(Vtt).order_by(Vtt.name).all()\n</code></pre>"},{"location":"architecture/repositories/#website.repositories.VttRepository.get_by_name","title":"<code>get_by_name(name)</code>","text":"<p>Find a VTT by its name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>VTT name to search for.</p> required <p>Returns:</p> Type Description <code>Vtt | None</code> <p>Vtt instance if found, None otherwise.</p> Source code in <code>website/repositories/vtt.py</code> <pre><code>def get_by_name(self, name: str) -&gt; Vtt | None:\n    \"\"\"Find a VTT by its name.\n\n    Args:\n        name: VTT name to search for.\n\n    Returns:\n        Vtt instance if found, None otherwise.\n    \"\"\"\n    return self.session.query(Vtt).filter_by(name=name).first()\n</code></pre>"},{"location":"architecture/services/","title":"Services","text":"<p>The service layer lives in <code>website/services/</code> and contains all business logic. Services are the primary place for new logic in QuestMaster.</p> <p>Services:</p> <ul> <li>Own transaction boundaries</li> <li>Perform validation and enforce business rules</li> <li>Raise domain-specific exceptions from <code>website.exceptions</code></li> <li>Call repositories for data access</li> <li>Never access Flask <code>request</code> or <code>session</code> directly</li> </ul>"},{"location":"architecture/services/#overview","title":"Overview","text":"Service Repository Model Description <code>ChannelService</code> <code>ChannelRepository</code> <code>Channel</code> Category size management and Discord channel cleanup <code>DiscordService</code> <code>Discord</code> (client) \u2014 Discord API wrapper with dependency injection for testability <code>GameService</code> <code>GameRepository</code> <code>Game</code> Complete game lifecycle \u2014 creation, publishing, registration, archival, Discord sync <code>GameEventService</code> <code>GameEventRepository</code> <code>GameEvent</code> Transaction-safe audit trail logging for games <code>GameSessionService</code> <code>GameSessionRepository</code> <code>GameSession</code> Session CRUD with conflict detection and validation <code>SpecialEventService</code> <code>SpecialEventRepository</code> <code>SpecialEvent</code> Special event CRUD with uniqueness validation <code>SystemService</code> <code>SystemRepository</code> <code>System</code> Game system CRUD with cache invalidation <code>TrophyService</code> <code>TrophyRepository</code> <code>Trophy</code> Trophy awarding logic (unique vs. non-unique rules) and leaderboards <code>UserService</code> <code>UserRepository</code> <code>User</code> User retrieval, creation, and Discord profile initialization <code>VttService</code> <code>VttRepository</code> <code>Vtt</code> Virtual tabletop CRUD with cache invalidation"},{"location":"architecture/services/#api-reference","title":"API Reference","text":"<p>Service layer for business logic and transaction management.</p>"},{"location":"architecture/services/#website.services.ChannelService","title":"<code>ChannelService</code>","text":"<p>Service layer for Channel (Discord category) management.</p> <p>Handles category size tracking for Discord channel organization.</p> Source code in <code>website/services/channel.py</code> <pre><code>class ChannelService:\n    \"\"\"Service layer for Channel (Discord category) management.\n\n    Handles category size tracking for Discord channel organization.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or ChannelRepository()\n\n    def get_category(self, game_type: str) -&gt; Channel:\n        \"\"\"Get the smallest category for a game type.\n\n        Args:\n            game_type: Type of game (oneshot, campaign).\n\n        Returns:\n            Channel category with smallest size.\n\n        Raises:\n            NotFoundError: If no category found for type.\n        \"\"\"\n        category = self.repo.get_smallest_by_type(game_type)\n        if not category:\n            raise NotFoundError(\n                f\"No channel category found for type '{game_type}'\",\n                resource_type=\"Channel\",\n            )\n        return category\n\n    def increment_size(self, channel: Channel) -&gt; None:\n        \"\"\"Increment the channel count for a category.\n\n        Args:\n            channel: Channel category to increment.\n        \"\"\"\n        self.repo.increment_size(channel)\n\n    def adjust_category_size(self, discord_service: DiscordService, game: Game) -&gt; None:\n        \"\"\"Decrement category size when a game channel is deleted.\n\n        Args:\n            discord_service: DiscordService instance for API calls.\n            game: Game instance with channel to look up.\n        \"\"\"\n        try:\n            discord_channel = discord_service.get_channel(game.channel)\n            parent_id = discord_channel.get(\"parent_id\")\n            if parent_id:\n                category = self.repo.get_by_id(parent_id)\n                if category:\n                    self.repo.decrement_size(category)\n                    db.session.commit()\n                    logger.info(f\"Decreased size of category {category.id} to {category.size}\")\n        except Exception as e:\n            logger.warning(f\"Failed to adjust category size for game {game.id}: {e}\")\n</code></pre>"},{"location":"architecture/services/#website.services.ChannelService.get_category","title":"<code>get_category(game_type)</code>","text":"<p>Get the smallest category for a game type.</p> <p>Parameters:</p> Name Type Description Default <code>game_type</code> <code>str</code> <p>Type of game (oneshot, campaign).</p> required <p>Returns:</p> Type Description <code>Channel</code> <p>Channel category with smallest size.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If no category found for type.</p> Source code in <code>website/services/channel.py</code> <pre><code>def get_category(self, game_type: str) -&gt; Channel:\n    \"\"\"Get the smallest category for a game type.\n\n    Args:\n        game_type: Type of game (oneshot, campaign).\n\n    Returns:\n        Channel category with smallest size.\n\n    Raises:\n        NotFoundError: If no category found for type.\n    \"\"\"\n    category = self.repo.get_smallest_by_type(game_type)\n    if not category:\n        raise NotFoundError(\n            f\"No channel category found for type '{game_type}'\",\n            resource_type=\"Channel\",\n        )\n    return category\n</code></pre>"},{"location":"architecture/services/#website.services.ChannelService.increment_size","title":"<code>increment_size(channel)</code>","text":"<p>Increment the channel count for a category.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <code>Channel</code> <p>Channel category to increment.</p> required Source code in <code>website/services/channel.py</code> <pre><code>def increment_size(self, channel: Channel) -&gt; None:\n    \"\"\"Increment the channel count for a category.\n\n    Args:\n        channel: Channel category to increment.\n    \"\"\"\n    self.repo.increment_size(channel)\n</code></pre>"},{"location":"architecture/services/#website.services.ChannelService.adjust_category_size","title":"<code>adjust_category_size(discord_service, game)</code>","text":"<p>Decrement category size when a game channel is deleted.</p> <p>Parameters:</p> Name Type Description Default <code>discord_service</code> <code>DiscordService</code> <p>DiscordService instance for API calls.</p> required <code>game</code> <code>Game</code> <p>Game instance with channel to look up.</p> required Source code in <code>website/services/channel.py</code> <pre><code>def adjust_category_size(self, discord_service: DiscordService, game: Game) -&gt; None:\n    \"\"\"Decrement category size when a game channel is deleted.\n\n    Args:\n        discord_service: DiscordService instance for API calls.\n        game: Game instance with channel to look up.\n    \"\"\"\n    try:\n        discord_channel = discord_service.get_channel(game.channel)\n        parent_id = discord_channel.get(\"parent_id\")\n        if parent_id:\n            category = self.repo.get_by_id(parent_id)\n            if category:\n                self.repo.decrement_size(category)\n                db.session.commit()\n                logger.info(f\"Decreased size of category {category.id} to {category.size}\")\n    except Exception as e:\n        logger.warning(f\"Failed to adjust category size for game {game.id}: {e}\")\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService","title":"<code>DiscordService</code>","text":"<p>Service layer for Discord API interactions.</p> <p>Provides a testable wrapper around the Discord API client. Uses dependency injection to allow mocking in tests.</p> <p>Attributes:</p> Name Type Description <code>bot</code> <code>Discord</code> <p>The underlying Discord API client instance.</p> Source code in <code>website/services/discord.py</code> <pre><code>class DiscordService:\n    \"\"\"Service layer for Discord API interactions.\n\n    Provides a testable wrapper around the Discord API client. Uses dependency\n    injection to allow mocking in tests.\n\n    Attributes:\n        bot: The underlying Discord API client instance.\n    \"\"\"\n\n    def __init__(self, bot: Optional[Discord] = None):\n        self._bot = bot\n\n    @property\n    def bot(self) -&gt; Discord:\n        \"\"\"Get the Discord bot instance.\n\n        Lazy-loads from the global singleton if not injected.\n\n        Returns:\n            Discord client instance.\n\n        Raises:\n            RuntimeError: If no bot instance is available.\n        \"\"\"\n        if self._bot is None:\n            from website.bot import get_bot\n\n            self._bot = get_bot()\n        if self._bot is None:\n            raise RuntimeError(\"Discord bot not initialized\")\n        return self._bot\n\n    # -------------------------------------------------------------------------\n    # User operations\n    # -------------------------------------------------------------------------\n\n    def get_user(self, user_id: str) -&gt; dict:\n        \"\"\"Fetch guild member data from Discord.\n\n        Args:\n            user_id: Discord user ID.\n\n        Returns:\n            Member data dictionary from Discord API.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.get_user(user_id)\n\n    def add_role_to_user(self, user_id: str, role_id: str) -&gt; dict:\n        \"\"\"Add a role to a user.\n\n        Args:\n            user_id: Discord user ID.\n            role_id: Discord role ID.\n\n        Returns:\n            API response (usually empty on success).\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.add_role_to_user(user_id, role_id)\n\n    def remove_role_from_user(self, user_id: str, role_id: str) -&gt; dict:\n        \"\"\"Remove a role from a user.\n\n        Args:\n            user_id: Discord user ID.\n            role_id: Discord role ID.\n\n        Returns:\n            API response (usually empty on success).\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.remove_role_from_user(user_id, role_id)\n\n    # -------------------------------------------------------------------------\n    # Role operations\n    # -------------------------------------------------------------------------\n\n    def create_role(\n        self,\n        name: str,\n        permissions: str = PLAYER_ROLE_PERMISSION,\n        color: int = 0,\n    ) -&gt; dict:\n        \"\"\"Create a Discord role.\n\n        Args:\n            name: Role name (will be sanitized).\n            permissions: Permission bitfield string.\n            color: Role color as integer.\n\n        Returns:\n            Created role data including 'id'.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.create_role(name, permissions, color)\n\n    def get_role(self, role_id: str) -&gt; dict:\n        \"\"\"Get a role by ID.\n\n        Args:\n            role_id: Discord role ID.\n\n        Returns:\n            Role data dictionary.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.get_role(role_id)\n\n    def delete_role(self, role_id: str) -&gt; dict:\n        \"\"\"Delete a Discord role.\n\n        Args:\n            role_id: Discord role ID.\n\n        Returns:\n            API response (usually empty on success).\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.delete_role(role_id)\n\n    # -------------------------------------------------------------------------\n    # Channel operations\n    # -------------------------------------------------------------------------\n\n    def create_channel(\n        self,\n        name: str,\n        parent_id: str,\n        role_id: str,\n        gm_id: str,\n    ) -&gt; dict:\n        \"\"\"Create a Discord text channel with permissions.\n\n        Args:\n            name: Channel name (will be sanitized).\n            parent_id: Parent category ID.\n            role_id: Player role ID for permission overwrites.\n            gm_id: GM user ID for permission overwrites.\n\n        Returns:\n            Created channel data including 'id'.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.create_channel(name, parent_id, role_id, gm_id)\n\n    def get_channel(self, channel_id: str) -&gt; dict:\n        \"\"\"Get a channel by ID.\n\n        Args:\n            channel_id: Discord channel ID.\n\n        Returns:\n            Channel data dictionary.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.get_channel(channel_id)\n\n    def delete_channel(self, channel_id: str) -&gt; dict:\n        \"\"\"Delete a Discord channel.\n\n        Args:\n            channel_id: Discord channel ID.\n\n        Returns:\n            API response (usually empty on success).\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.delete_channel(channel_id)\n\n    # -------------------------------------------------------------------------\n    # Message operations\n    # -------------------------------------------------------------------------\n\n    def send_message(self, content: str, channel_id: str) -&gt; dict:\n        \"\"\"Send a plain text message to a channel.\n\n        Args:\n            content: Message content.\n            channel_id: Target channel ID.\n\n        Returns:\n            Created message data including 'id'.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.send_message(content, channel_id)\n\n    def delete_message(self, message_id: str, channel_id: str) -&gt; dict:\n        \"\"\"Delete a message.\n\n        Args:\n            message_id: Discord message ID.\n            channel_id: Channel containing the message.\n\n        Returns:\n            API response (usually empty on success).\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.delete_message(message_id, channel_id)\n\n    def send_embed(self, embed: dict, channel_id: str) -&gt; dict:\n        \"\"\"Send an embed message to a channel.\n\n        Args:\n            embed: Embed data dictionary.\n            channel_id: Target channel ID.\n\n        Returns:\n            Created message data including 'id'.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.send_embed_message(embed, channel_id)\n\n    def edit_embed(self, message_id: str, embed: dict, channel_id: str) -&gt; dict:\n        \"\"\"Edit an existing embed message.\n\n        Args:\n            message_id: Message ID to edit.\n            embed: New embed data dictionary.\n            channel_id: Channel containing the message.\n\n        Returns:\n            Updated message data.\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.edit_embed_message(message_id, embed, channel_id)\n\n    def pin_message(self, message_id: str, channel_id: str) -&gt; dict:\n        \"\"\"Pin a message to a channel.\n\n        Args:\n            message_id: Message ID to edit.\n            channel_id: Target channel ID.\n\n        Returns:\n            API response (usually empty on success).\n\n        Raises:\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        return self.bot.pin_message(message_id, channel_id)\n\n    # -------------------------------------------------------------------------\n    # Game embed operations (high-level)\n    # -------------------------------------------------------------------------\n\n    def send_game_embed(\n        self,\n        game: Game,\n        embed_type: str = \"annonce\",\n        start: Optional[datetime] = None,\n        end: Optional[datetime] = None,\n        player: Optional[str] = None,\n        old_start: Optional[datetime] = None,\n        old_end: Optional[datetime] = None,\n        alert_message: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"Send or update a Discord embed for a game event.\n\n        This is a high-level method that builds and sends the appropriate embed\n        based on the embed_type.\n\n        Args:\n            game: Game model instance.\n            embed_type: Type of embed ('annonce', 'annonce_details', 'add-session',\n                'edit-session', 'del-session', 'register', 'alert').\n            start: Session start datetime (for session embeds).\n            end: Session end datetime (for session embeds).\n            player: Player user ID (for register/alert embeds).\n            old_start: Previous session start (for edit-session).\n            old_end: Previous session end (for edit-session).\n            alert_message: Alert text (for alert embed).\n\n        Returns:\n            Discord message ID string.\n\n        Raises:\n            ValueError: If embed_type is unknown.\n            DiscordAPIError: If the API request fails.\n        \"\"\"\n        from website.utils.game_embeds import (\n            build_add_session_embed,\n            build_alert_embed,\n            build_annonce_details_embed,\n            build_annonce_embed,\n            build_delete_session_embed,\n            build_edit_session_embed,\n            build_register_embed,\n        )\n\n        embed_builders = {\n            \"annonce\": build_annonce_embed,\n            \"annonce_details\": build_annonce_details_embed,\n            \"add-session\": build_add_session_embed,\n            \"edit-session\": build_edit_session_embed,\n            \"del-session\": build_delete_session_embed,\n            \"register\": build_register_embed,\n            \"alert\": build_alert_embed,\n        }\n\n        if embed_type not in embed_builders:\n            raise ValueError(f\"Unknown embed type: {embed_type}\")\n\n        embed, target = embed_builders[embed_type](\n            game, start, end, player, old_start, old_end, alert_message\n        )\n\n        if embed_type == \"annonce\" and game.msg_id:\n            response = self.edit_embed(game.msg_id, embed, target)\n        else:\n            response = self.send_embed(embed, target)\n\n        return response[\"id\"]\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.bot","title":"<code>bot</code>  <code>property</code>","text":"<p>Get the Discord bot instance.</p> <p>Lazy-loads from the global singleton if not injected.</p> <p>Returns:</p> Type Description <code>Discord</code> <p>Discord client instance.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If no bot instance is available.</p>"},{"location":"architecture/services/#website.services.DiscordService.get_user","title":"<code>get_user(user_id)</code>","text":"<p>Fetch guild member data from Discord.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Member data dictionary from Discord API.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def get_user(self, user_id: str) -&gt; dict:\n    \"\"\"Fetch guild member data from Discord.\n\n    Args:\n        user_id: Discord user ID.\n\n    Returns:\n        Member data dictionary from Discord API.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.get_user(user_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.add_role_to_user","title":"<code>add_role_to_user(user_id, role_id)</code>","text":"<p>Add a role to a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <code>role_id</code> <code>str</code> <p>Discord role ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>API response (usually empty on success).</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def add_role_to_user(self, user_id: str, role_id: str) -&gt; dict:\n    \"\"\"Add a role to a user.\n\n    Args:\n        user_id: Discord user ID.\n        role_id: Discord role ID.\n\n    Returns:\n        API response (usually empty on success).\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.add_role_to_user(user_id, role_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.remove_role_from_user","title":"<code>remove_role_from_user(user_id, role_id)</code>","text":"<p>Remove a role from a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <code>role_id</code> <code>str</code> <p>Discord role ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>API response (usually empty on success).</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def remove_role_from_user(self, user_id: str, role_id: str) -&gt; dict:\n    \"\"\"Remove a role from a user.\n\n    Args:\n        user_id: Discord user ID.\n        role_id: Discord role ID.\n\n    Returns:\n        API response (usually empty on success).\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.remove_role_from_user(user_id, role_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.create_role","title":"<code>create_role(name, permissions=PLAYER_ROLE_PERMISSION, color=0)</code>","text":"<p>Create a Discord role.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Role name (will be sanitized).</p> required <code>permissions</code> <code>str</code> <p>Permission bitfield string.</p> <code>PLAYER_ROLE_PERMISSION</code> <code>color</code> <code>int</code> <p>Role color as integer.</p> <code>0</code> <p>Returns:</p> Type Description <code>dict</code> <p>Created role data including 'id'.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def create_role(\n    self,\n    name: str,\n    permissions: str = PLAYER_ROLE_PERMISSION,\n    color: int = 0,\n) -&gt; dict:\n    \"\"\"Create a Discord role.\n\n    Args:\n        name: Role name (will be sanitized).\n        permissions: Permission bitfield string.\n        color: Role color as integer.\n\n    Returns:\n        Created role data including 'id'.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.create_role(name, permissions, color)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.get_role","title":"<code>get_role(role_id)</code>","text":"<p>Get a role by ID.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Discord role ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Role data dictionary.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def get_role(self, role_id: str) -&gt; dict:\n    \"\"\"Get a role by ID.\n\n    Args:\n        role_id: Discord role ID.\n\n    Returns:\n        Role data dictionary.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.get_role(role_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.delete_role","title":"<code>delete_role(role_id)</code>","text":"<p>Delete a Discord role.</p> <p>Parameters:</p> Name Type Description Default <code>role_id</code> <code>str</code> <p>Discord role ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>API response (usually empty on success).</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def delete_role(self, role_id: str) -&gt; dict:\n    \"\"\"Delete a Discord role.\n\n    Args:\n        role_id: Discord role ID.\n\n    Returns:\n        API response (usually empty on success).\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.delete_role(role_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.create_channel","title":"<code>create_channel(name, parent_id, role_id, gm_id)</code>","text":"<p>Create a Discord text channel with permissions.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Channel name (will be sanitized).</p> required <code>parent_id</code> <code>str</code> <p>Parent category ID.</p> required <code>role_id</code> <code>str</code> <p>Player role ID for permission overwrites.</p> required <code>gm_id</code> <code>str</code> <p>GM user ID for permission overwrites.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Created channel data including 'id'.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def create_channel(\n    self,\n    name: str,\n    parent_id: str,\n    role_id: str,\n    gm_id: str,\n) -&gt; dict:\n    \"\"\"Create a Discord text channel with permissions.\n\n    Args:\n        name: Channel name (will be sanitized).\n        parent_id: Parent category ID.\n        role_id: Player role ID for permission overwrites.\n        gm_id: GM user ID for permission overwrites.\n\n    Returns:\n        Created channel data including 'id'.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.create_channel(name, parent_id, role_id, gm_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.get_channel","title":"<code>get_channel(channel_id)</code>","text":"<p>Get a channel by ID.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>Discord channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Channel data dictionary.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def get_channel(self, channel_id: str) -&gt; dict:\n    \"\"\"Get a channel by ID.\n\n    Args:\n        channel_id: Discord channel ID.\n\n    Returns:\n        Channel data dictionary.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.get_channel(channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.delete_channel","title":"<code>delete_channel(channel_id)</code>","text":"<p>Delete a Discord channel.</p> <p>Parameters:</p> Name Type Description Default <code>channel_id</code> <code>str</code> <p>Discord channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>API response (usually empty on success).</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def delete_channel(self, channel_id: str) -&gt; dict:\n    \"\"\"Delete a Discord channel.\n\n    Args:\n        channel_id: Discord channel ID.\n\n    Returns:\n        API response (usually empty on success).\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.delete_channel(channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.send_message","title":"<code>send_message(content, channel_id)</code>","text":"<p>Send a plain text message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>Message content.</p> required <code>channel_id</code> <code>str</code> <p>Target channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Created message data including 'id'.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def send_message(self, content: str, channel_id: str) -&gt; dict:\n    \"\"\"Send a plain text message to a channel.\n\n    Args:\n        content: Message content.\n        channel_id: Target channel ID.\n\n    Returns:\n        Created message data including 'id'.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.send_message(content, channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.delete_message","title":"<code>delete_message(message_id, channel_id)</code>","text":"<p>Delete a message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>Discord message ID.</p> required <code>channel_id</code> <code>str</code> <p>Channel containing the message.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>API response (usually empty on success).</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def delete_message(self, message_id: str, channel_id: str) -&gt; dict:\n    \"\"\"Delete a message.\n\n    Args:\n        message_id: Discord message ID.\n        channel_id: Channel containing the message.\n\n    Returns:\n        API response (usually empty on success).\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.delete_message(message_id, channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.send_embed","title":"<code>send_embed(embed, channel_id)</code>","text":"<p>Send an embed message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>embed</code> <code>dict</code> <p>Embed data dictionary.</p> required <code>channel_id</code> <code>str</code> <p>Target channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Created message data including 'id'.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def send_embed(self, embed: dict, channel_id: str) -&gt; dict:\n    \"\"\"Send an embed message to a channel.\n\n    Args:\n        embed: Embed data dictionary.\n        channel_id: Target channel ID.\n\n    Returns:\n        Created message data including 'id'.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.send_embed_message(embed, channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.edit_embed","title":"<code>edit_embed(message_id, embed, channel_id)</code>","text":"<p>Edit an existing embed message.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>Message ID to edit.</p> required <code>embed</code> <code>dict</code> <p>New embed data dictionary.</p> required <code>channel_id</code> <code>str</code> <p>Channel containing the message.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Updated message data.</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def edit_embed(self, message_id: str, embed: dict, channel_id: str) -&gt; dict:\n    \"\"\"Edit an existing embed message.\n\n    Args:\n        message_id: Message ID to edit.\n        embed: New embed data dictionary.\n        channel_id: Channel containing the message.\n\n    Returns:\n        Updated message data.\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.edit_embed_message(message_id, embed, channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.pin_message","title":"<code>pin_message(message_id, channel_id)</code>","text":"<p>Pin a message to a channel.</p> <p>Parameters:</p> Name Type Description Default <code>message_id</code> <code>str</code> <p>Message ID to edit.</p> required <code>channel_id</code> <code>str</code> <p>Target channel ID.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>API response (usually empty on success).</p> <p>Raises:</p> Type Description <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def pin_message(self, message_id: str, channel_id: str) -&gt; dict:\n    \"\"\"Pin a message to a channel.\n\n    Args:\n        message_id: Message ID to edit.\n        channel_id: Target channel ID.\n\n    Returns:\n        API response (usually empty on success).\n\n    Raises:\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    return self.bot.pin_message(message_id, channel_id)\n</code></pre>"},{"location":"architecture/services/#website.services.DiscordService.send_game_embed","title":"<code>send_game_embed(game, embed_type='annonce', start=None, end=None, player=None, old_start=None, old_end=None, alert_message=None)</code>","text":"<p>Send or update a Discord embed for a game event.</p> <p>This is a high-level method that builds and sends the appropriate embed based on the embed_type.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Game model instance.</p> required <code>embed_type</code> <code>str</code> <p>Type of embed ('annonce', 'annonce_details', 'add-session', 'edit-session', 'del-session', 'register', 'alert').</p> <code>'annonce'</code> <code>start</code> <code>Optional[datetime]</code> <p>Session start datetime (for session embeds).</p> <code>None</code> <code>end</code> <code>Optional[datetime]</code> <p>Session end datetime (for session embeds).</p> <code>None</code> <code>player</code> <code>Optional[str]</code> <p>Player user ID (for register/alert embeds).</p> <code>None</code> <code>old_start</code> <code>Optional[datetime]</code> <p>Previous session start (for edit-session).</p> <code>None</code> <code>old_end</code> <code>Optional[datetime]</code> <p>Previous session end (for edit-session).</p> <code>None</code> <code>alert_message</code> <code>Optional[str]</code> <p>Alert text (for alert embed).</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Discord message ID string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If embed_type is unknown.</p> <code>DiscordAPIError</code> <p>If the API request fails.</p> Source code in <code>website/services/discord.py</code> <pre><code>def send_game_embed(\n    self,\n    game: Game,\n    embed_type: str = \"annonce\",\n    start: Optional[datetime] = None,\n    end: Optional[datetime] = None,\n    player: Optional[str] = None,\n    old_start: Optional[datetime] = None,\n    old_end: Optional[datetime] = None,\n    alert_message: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Send or update a Discord embed for a game event.\n\n    This is a high-level method that builds and sends the appropriate embed\n    based on the embed_type.\n\n    Args:\n        game: Game model instance.\n        embed_type: Type of embed ('annonce', 'annonce_details', 'add-session',\n            'edit-session', 'del-session', 'register', 'alert').\n        start: Session start datetime (for session embeds).\n        end: Session end datetime (for session embeds).\n        player: Player user ID (for register/alert embeds).\n        old_start: Previous session start (for edit-session).\n        old_end: Previous session end (for edit-session).\n        alert_message: Alert text (for alert embed).\n\n    Returns:\n        Discord message ID string.\n\n    Raises:\n        ValueError: If embed_type is unknown.\n        DiscordAPIError: If the API request fails.\n    \"\"\"\n    from website.utils.game_embeds import (\n        build_add_session_embed,\n        build_alert_embed,\n        build_annonce_details_embed,\n        build_annonce_embed,\n        build_delete_session_embed,\n        build_edit_session_embed,\n        build_register_embed,\n    )\n\n    embed_builders = {\n        \"annonce\": build_annonce_embed,\n        \"annonce_details\": build_annonce_details_embed,\n        \"add-session\": build_add_session_embed,\n        \"edit-session\": build_edit_session_embed,\n        \"del-session\": build_delete_session_embed,\n        \"register\": build_register_embed,\n        \"alert\": build_alert_embed,\n    }\n\n    if embed_type not in embed_builders:\n        raise ValueError(f\"Unknown embed type: {embed_type}\")\n\n    embed, target = embed_builders[embed_type](\n        game, start, end, player, old_start, old_end, alert_message\n    )\n\n    if embed_type == \"annonce\" and game.msg_id:\n        response = self.edit_embed(game.msg_id, embed, target)\n    else:\n        response = self.send_embed(embed, target)\n\n    return response[\"id\"]\n</code></pre>"},{"location":"architecture/services/#website.services.GameService","title":"<code>GameService</code>","text":"<p>Service layer for Game business logic.</p> <p>Handles game creation, updates, status transitions, player registration, and Discord integration. Owns transaction boundaries (commits).</p> Source code in <code>website/services/game.py</code> <pre><code>class GameService:\n    \"\"\"Service layer for Game business logic.\n\n    Handles game creation, updates, status transitions, player registration,\n    and Discord integration. Owns transaction boundaries (commits).\n    \"\"\"\n\n    def __init__(\n        self,\n        repository=None,\n        user_service=None,\n        channel_service=None,\n        session_service=None,\n        trophy_service=None,\n        discord_service=None,\n    ):\n        from website.services.discord import DiscordService\n\n        self.repo = repository or GameRepository()\n        self.user_service = user_service or UserService()\n        self.channel_service = channel_service or ChannelService()\n        self.session_service = session_service or GameSessionService()\n        self.trophy_service = trophy_service or TrophyService()\n        self.discord = discord_service or DiscordService()\n\n    def get_by_id(self, game_id: int) -&gt; Game:\n        \"\"\"Get game by ID.\n\n        Args:\n            game_id: Game ID.\n\n        Returns:\n            Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.repo.get_by_id(game_id)\n        if not game:\n            raise NotFoundError(\n                f\"Game with id {game_id} not found\",\n                resource_type=\"Game\",\n                resource_id=game_id,\n            )\n        return game\n\n    def get_by_slug(self, slug: str) -&gt; Game:\n        \"\"\"Get game by slug.\n\n        Args:\n            slug: URL-safe game identifier.\n\n        Returns:\n            Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.repo.get_by_slug(slug)\n        if not game:\n            raise NotFoundError(\n                f\"Game with slug '{slug}' not found\",\n                resource_type=\"Game\",\n                resource_id=slug,\n            )\n        return game\n\n    def get_by_slug_or_404(self, slug: str) -&gt; Game:\n        \"\"\"Get game by slug or raise 404 (for Flask routes).\n\n        Args:\n            slug: URL-safe game identifier.\n\n        Returns:\n            Game instance.\n\n        Raises:\n            NotFound: Flask 404 error.\n        \"\"\"\n        return self.repo.get_by_slug_or_404(slug)\n\n    def generate_slug(self, name: str, gm_name: str) -&gt; str:\n        \"\"\"Generate unique slug for a game.\n\n        Args:\n            name: Game name.\n            gm_name: GM stable username (preferred) or display name (fallback).\n\n        Returns:\n            Unique URL-safe slug.\n        \"\"\"\n        existing_slugs = self.repo.get_all_slugs()\n        base_slug = slugify(f\"{name}-par-{gm_name}\")\n        slug = base_slug\n        i = 2\n        while slug in existing_slugs:\n            slug = f\"{base_slug}-{i}\"\n            i += 1\n        return slug\n\n    def parse_game_type(self, type_value: str) -&gt; tuple[str, Optional[int]]:\n        \"\"\"Parse game type value from form.\n\n        Args:\n            type_value: Type string, possibly \"specialevent-&lt;id&gt;\".\n\n        Returns:\n            Tuple of (game_type, special_event_id).\n        \"\"\"\n        special_event_id = None\n        game_type = type_value\n\n        if type_value and type_value.startswith(\"specialevent-\"):\n            try:\n                special_event_id = int(type_value.split(\"-\", 1)[1])\n            except (ValueError, IndexError):\n                special_event_id = None\n            game_type = \"oneshot\"  # all special events are treated as oneshots\n\n        return game_type, special_event_id\n\n    def create(\n        self,\n        data: dict,\n        gm_id: str,\n        status: str = \"draft\",\n        create_resources: bool = False,\n    ) -&gt; Game:\n        \"\"\"Create a new game.\n\n        Args:\n            data: Game data dictionary from form.\n            gm_id: GM user ID.\n            status: Initial status (draft, open, closed).\n            create_resources: Whether to create Discord resources (role, channel).\n\n        Returns:\n            Created Game instance.\n\n        Raises:\n            ValidationError: If data is invalid.\n            DiscordAPIError: If Discord resource creation fails.\n        \"\"\"\n        from config.constants import DEFAULT_TIMEFORMAT\n        from website.utils.form_parsers import (\n            get_ambience,\n            get_classification,\n            parse_restriction_tags,\n        )\n\n        try:\n            # Parse special fields\n            game_type, special_event_id = self.parse_game_type(data[\"type\"])\n\n            # Get GM name for slug\n            gm = self.user_service.get_by_id(gm_id)\n\n            # Create game instance\n            game = Game(\n                name=data[\"name\"],\n                type=game_type,\n                special_event_id=special_event_id,\n                length=data[\"length\"],\n                gm_id=gm_id,\n                system_id=data[\"system\"],\n                vtt_id=data.get(\"vtt\") or None,\n                description=data[\"description\"],\n                restriction=data[\"restriction\"],\n                party_size=data[\"party_size\"],\n                xp=data[\"xp\"],\n                date=datetime.strptime(data[\"date\"], DEFAULT_TIMEFORMAT),\n                session_length=data[\"session_length\"],\n                frequency=data.get(\"frequency\") or None,\n                characters=data[\"characters\"],\n                classification=get_classification(),\n                ambience=get_ambience(data),\n                complement=data.get(\"complement\"),\n                status=status,\n                img=data.get(\"img\"),\n                party_selection=\"party_selection\" in data,\n                restriction_tags=parse_restriction_tags(data),\n            )\n\n            # Generate unique slug\n            game.slug = self.generate_slug(data[\"name\"], gm.slug_name)\n\n            # Add to session\n            self.repo.add(game)\n            db.session.flush()  # Ensure game.id is available\n\n            logger.info(f\"Game object created: {game.name} with slug {game.slug}\")\n\n            # Create Discord resources if requested\n            if create_resources:\n                self._setup_game_resources(game)\n                logger.info(\"Game post-creation setup completed.\")\n\n            db.session.commit()\n            log_game_event(\n                \"create\",\n                game.id,\n                f\"Annonce cr\u00e9\u00e9e avec le statut {game.status}.\",\n                user_id=game.gm_id,\n            )\n            logger.info(f\"Game saved in DB with ID: {game.id}\")\n\n            return game\n\n        except ValidationError:\n            db.session.rollback()\n            raise\n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Failed to create game: {e}\", exc_info=True)\n            # Rollback Discord resources if they were created\n            if create_resources and hasattr(game, \"role\"):\n                self._rollback_discord_resources(game)\n            raise\n\n    def _setup_game_resources(self, game: Game) -&gt; None:\n        \"\"\"Set up Discord resources for a game (role, channel, session, channel message).\n\n        Args:\n            game: Game instance.\n\n        Raises:\n            DiscordAPIError: If Discord operations fail.\n        \"\"\"\n        # Create initial game session\n        self.session_service.create(\n            game,\n            game.date,\n            game.date + timedelta(hours=float(game.session_length)),\n        )\n        logger.info(\"Initial game session created.\")\n\n        # Create Discord role\n        game.role = self.discord.create_role(\n            name=\"PJ_\" + game.slug,\n            permissions=PLAYER_ROLE_PERMISSION,\n            color=Game.COLORS[game.type],\n        )[\"id\"]\n        logger.info(f\"Role created with ID: {game.role}\")\n\n        # Create Discord channel\n        category = self.channel_service.get_category(game.type)\n        game.channel = self.discord.create_channel(\n            name=game.slug.lower(),\n            parent_id=category.id,\n            role_id=game.role,\n            gm_id=game.gm_id,\n        )[\"id\"]\n        logger.info(f\"Channel created with ID: {game.channel} under category: {category.id}\")\n\n        self.channel_service.increment_size(category)\n\n        # Post and pin initial message in the game channel\n        msg_id = self.discord.send_game_embed(game, embed_type=\"annonce_details\")\n        self.discord.pin_message(msg_id, game.channel)\n        logger.info(\"Initial channel message posted and pinned.\")\n\n    def _rollback_discord_resources(self, game: Game) -&gt; None:\n        \"\"\"Rollback Discord resources on error.\n\n        Args:\n            game: Game instance with potentially created resources.\n        \"\"\"\n        if game.channel:\n            self.discord.delete_channel(game.channel)\n            logger.info(f\"Channel {game.channel} deleted\")\n        if game.role:\n            self.discord.delete_role(game.role)\n            logger.info(f\"Role {game.role} deleted\")\n\n    def update(self, slug: str, data: dict, user_id: str | None = None) -&gt; Game:\n        \"\"\"Update an existing game.\n\n        Args:\n            slug: Game slug.\n            data: Updated game data.\n            user_id: ID of the user performing the update.\n\n        Returns:\n            Updated Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n            ValidationError: If data is invalid.\n        \"\"\"\n        from config.constants import DEFAULT_TIMEFORMAT\n        from website.utils.form_parsers import (\n            get_ambience,\n            get_classification,\n            parse_restriction_tags,\n        )\n\n        game = self.get_by_slug(slug)\n\n        try:\n            # Only allow type/name changes if game is draft\n            if game.status == \"draft\":\n                game_type, special_event_id = self.parse_game_type(data[\"type\"])\n                game.type = game_type\n                game.special_event_id = special_event_id\n                game.name = data[\"name\"]\n\n            # Update fields\n            game.system_id = data[\"system\"]\n            game.vtt_id = data.get(\"vtt\") or None\n            game.description = data[\"description\"]\n            game.date = datetime.strptime(data[\"date\"], DEFAULT_TIMEFORMAT)\n            game.length = data[\"length\"]\n            game.party_size = data[\"party_size\"]\n            game.party_selection = \"party_selection\" in data\n            game.xp = data[\"xp\"]\n            game.session_length = data[\"session_length\"]\n            game.frequency = data.get(\"frequency\") or None\n            game.characters = data[\"characters\"]\n            game.classification = get_classification()\n            game.ambience = get_ambience(data)\n            game.complement = data.get(\"complement\")\n            game.img = data.get(\"img\")\n            game.restriction = data[\"restriction\"]\n            game.restriction_tags = parse_restriction_tags(data)\n\n            db.session.commit()\n            log_game_event(\n                \"edit\", game.id, \"Le contenu de l'annonce a \u00e9t\u00e9 \u00e9dit\u00e9.\", user_id=user_id\n            )\n            logger.info(f\"Game {game.id} changes saved\")\n\n            # Update Discord embed if message exists\n            if game.msg_id:\n                try:\n                    self.discord.send_game_embed(game, embed_type=\"annonce\")\n                    logger.info(f\"Embed updated for game {game.id}\")\n                except DiscordAPIError as e:\n                    logger.warning(f\"Failed to update Discord embed for game {game.id}: {e}\")\n\n            return game\n\n        except ValidationError:\n            db.session.rollback()\n            raise\n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Failed to update game {game.id}: {e}\", exc_info=True)\n            raise\n\n    def publish(self, slug: str, silent: bool = False, user_id: str | None = None) -&gt; Game:\n        \"\"\"Publish a draft game to Discord.\n\n        Args:\n            slug: Game slug.\n            silent: If True, don't send announcement (set to closed instead of open).\n            user_id: ID of the user performing the publish.\n\n        Returns:\n            Published Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n            ValidationError: If game is already published or is full.\n            DiscordAPIError: If Discord operations fail.\n        \"\"\"\n        game = self.get_by_slug(slug)\n\n        if game.msg_id:\n            raise ValidationError(\"Game is already published.\", field=\"status\")\n\n        if len(game.players) &gt;= game.party_size:\n            raise ValidationError(\"Cannot publish a full game.\", field=\"party_size\")\n\n        try:\n            game.status = \"closed\" if silent else \"open\"\n\n            # Set up resources if not already created\n            if not game.role or not game.channel:\n                self._setup_game_resources(game)\n\n            # Send Discord announcement if not silent\n            if not silent:\n                game.msg_id = self.discord.send_game_embed(game, embed_type=\"annonce\")\n                logger.info(f\"Discord embed sent with message ID: {game.msg_id}\")\n\n            db.session.commit()\n            log_game_event(\n                \"edit\",\n                game.id,\n                (\n                    \"L'annonce a \u00e9t\u00e9 publi\u00e9e et ouverte.\"\n                    if not silent\n                    else \"L'annonce a \u00e9t\u00e9 ouverte silencieusement.\"\n                ),\n                user_id=user_id,\n            )\n            logger.info(\n                f\"Game {game.id} published and {'opened' if not silent else 'opened silently'}.\"\n            )\n\n            return game\n\n        except Exception as e:\n            db.session.rollback()\n            logger.error(f\"Failed to publish game {game.id}: {e}\", exc_info=True)\n            # Rollback Discord resources if they were just created\n            if not game.role or not game.channel:\n                self._rollback_discord_resources(game)\n            raise\n\n    def close(self, slug: str, user_id: str | None = None) -&gt; Game:\n        \"\"\"Close a game to new registrations.\n\n        Args:\n            slug: Game slug.\n            user_id: ID of the user performing the close.\n\n        Returns:\n            Updated Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        game.status = \"closed\"\n\n        db.session.commit()\n        log_game_event(\n            \"edit\", game.id, \"Le statut de l'annonce \u00e0 chang\u00e9 en closed.\", user_id=user_id\n        )\n        logger.info(f\"Game status for {game.id} has been updated to closed\")\n\n        # Update Discord embed\n        if game.msg_id:\n            try:\n                self.discord.send_game_embed(game, embed_type=\"annonce\")\n                logger.info(f\"Embed updated due to status change for game {game.id}\")\n            except DiscordAPIError as e:\n                logger.warning(f\"Failed to update embed on status change for game {game.id}: {e}\")\n\n        return game\n\n    def reopen(self, slug: str, user_id: str | None = None) -&gt; Game:\n        \"\"\"Reopen a closed game.\n\n        Args:\n            slug: Game slug.\n            user_id: ID of the user performing the reopen.\n\n        Returns:\n            Updated Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        game.status = \"open\"\n\n        db.session.commit()\n        log_game_event(\n            \"edit\", game.id, \"Le statut de l'annonce \u00e0 chang\u00e9 en open.\", user_id=user_id\n        )\n        logger.info(f\"Game status for {game.id} has been updated to open\")\n\n        # Update Discord embed\n        if game.msg_id:\n            try:\n                self.discord.send_game_embed(game, embed_type=\"annonce\")\n                logger.info(f\"Embed updated due to status change for game {game.id}\")\n            except DiscordAPIError as e:\n                logger.warning(f\"Failed to update embed on status change for game {game.id}: {e}\")\n\n        return game\n\n    def archive(self, slug: str, award_trophies: bool = True, user_id: str | None = None) -&gt; None:\n        \"\"\"Archive a game and clean up Discord resources.\n\n        Args:\n            slug: Game slug.\n            award_trophies: Whether to award trophies to participants.\n            user_id: ID of the user performing the archive.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        game.status = \"archived\"\n\n        db.session.commit()\n        log_game_event(\n            \"edit\", game.id, \"Le statut de l'annonce \u00e0 chang\u00e9 en archived.\", user_id=user_id\n        )\n        logger.info(f\"Game status for {game.id} has been updated to archived\")\n\n        # Award trophies\n        msg = \"Annonce archiv\u00e9e.\"\n        if award_trophies:\n            self._award_game_trophies(game)\n            msg += \" Badges distribu\u00e9s.\"\n        else:\n            msg += \" Badges non-distribu\u00e9s.\"\n\n        # Clean up Discord resources\n        self._cleanup_discord_resources(game)\n        self._delete_game_message(game)\n\n        log_game_event(\"delete\", game.id, msg, user_id=user_id)\n\n    def _award_game_trophies(self, game: Game) -&gt; None:\n        \"\"\"Award trophies to GM and players.\n\n        Args:\n            game: Game instance.\n        \"\"\"\n        trophy_map = {\n            \"oneshot\": (BADGE_OS_GM_ID, BADGE_OS_ID),\n            \"campaign\": (BADGE_CAMPAIGN_GM_ID, BADGE_CAMPAIGN_ID),\n        }\n        gm_trophy, player_trophy = trophy_map.get(game.type, (None, None))\n        if gm_trophy:\n            try:\n                self.trophy_service.award(user_id=game.gm.id, trophy_id=gm_trophy)\n                for user in game.players:\n                    self.trophy_service.award(user_id=user.id, trophy_id=player_trophy)\n            except Exception as e:\n                logger.error(f\"Failed to award trophies for game {game.id}: {e}\")\n\n    def _cleanup_discord_resources(self, game: Game) -&gt; None:\n        \"\"\"Clean up Discord resources for a game.\n\n        Args:\n            game: Game instance.\n        \"\"\"\n        self.channel_service.adjust_category_size(self.discord, game)\n\n        try:\n            self.discord.delete_channel(game.channel)\n            logger.info(f\"Game {game.id} channel {game.channel} has been deleted\")\n        except DiscordAPIError as e:\n            logger.warning(f\"Failed to delete channel for game {game.id}: {e}\")\n\n        try:\n            self.discord.delete_role(game.role)\n            logger.info(f\"Game {game.id} role {game.role} has been deleted\")\n        except DiscordAPIError as e:\n            logger.warning(f\"Failed to delete role for game {game.id}: {e}\")\n\n    def _delete_game_message(self, game: Game) -&gt; None:\n        \"\"\"Delete Discord announcement message.\n\n        Args:\n            game: Game instance.\n        \"\"\"\n        if not game.msg_id:\n            return\n\n        try:\n            self.discord.delete_message(game.msg_id, current_app.config[\"POSTS_CHANNEL_ID\"])\n            game.msg_id = None\n            db.session.commit()\n            logger.info(f\"Discord embed message deleted for archived game {game.id}\")\n        except DiscordAPIError as e:\n            logger.warning(f\"Failed to delete message for archived game {game.id}: {e}\")\n\n    def delete(self, slug: str) -&gt; None:\n        \"\"\"Delete a game permanently.\n\n        Args:\n            slug: Game slug.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        self.repo.delete_by_id(game.id)\n        db.session.commit()\n        logger.info(f\"Game {game.id} has been deleted.\")\n\n    def register_player(self, slug: str, user_id: str, force: bool = False) -&gt; Game:\n        \"\"\"Register a player to a game (concurrent-safe).\n\n        Args:\n            slug: Game slug.\n            user_id: User ID to register.\n            force: If True, bypass capacity and status checks.\n\n        Returns:\n            Updated Game instance.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n            DuplicateRegistrationError: If user is already registered.\n            GameFullError: If game is at capacity and force is False.\n            GameClosedError: If game is closed and force is False.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        user = self.user_service.get_by_id(user_id)\n\n        try:\n            # Lock the game row for update\n            locked_game = self.repo.get_for_update(game.id)\n            if not locked_game:\n                raise NotFoundError(\n                    f\"Game with id {game.id} not found\",\n                    resource_type=\"Game\",\n                    resource_id=game.id,\n                )\n\n            # Check if already registered\n            if user in locked_game.players:\n                raise DuplicateRegistrationError(\n                    \"User is already registered for this game.\",\n                    game_id=locked_game.id,\n                    user_id=user.id,\n                )\n\n            # Check capacity\n            if len(locked_game.players) &gt;= locked_game.party_size and not force:\n                raise GameFullError(\n                    \"Game is full.\",\n                    game_id=locked_game.id,\n                    max_players=locked_game.party_size,\n                )\n\n            # Check status\n            if locked_game.status == \"closed\" and not force:\n                raise GameClosedError(\n                    \"Game is closed for registration.\",\n                    game_id=locked_game.id,\n                )\n\n            # Add player\n            locked_game.players.append(user)\n\n            # Auto-close if full\n            if (\n                len(locked_game.players) &gt;= locked_game.party_size\n                and not locked_game.party_selection\n            ):\n                locked_game.status = \"closed\"\n                if locked_game.msg_id:\n                    try:\n                        self.discord.send_game_embed(locked_game, embed_type=\"annonce\")\n                        logger.info(\n                            f\"Embed updated due to status change for game {locked_game.id}\"\n                        )\n                    except DiscordAPIError as e:\n                        logger.warning(\n                            \"Failed to update embed on status change \"\n                            f\"for game {locked_game.id}: {e}\"\n                        )\n                log_game_event(\n                    \"edit\",\n                    locked_game.id,\n                    \"Annonce ferm\u00e9e automatiquement apr\u00e8s avoir atteint le nombre \"\n                    f\"max de joueur\u00b7euses ({locked_game.party_size}).\",\n                )\n                logger.info(f\"Game status for {locked_game.id} has been updated to closed\")\n\n            db.session.commit()\n\n            # Log event\n            if force:\n                log_game_event(\n                    \"register\",\n                    locked_game.id,\n                    \"Le\u00b7a joueur\u00b7euse a \u00e9t\u00e9 ajout\u00e9\u00b7e \u00e0 la partie par le MJ.\",\n                    user_id=user.id,\n                )\n            else:\n                log_game_event(\n                    \"register\",\n                    locked_game.id,\n                    \"Le\u00b7a joueur\u00b7euse s'est inscrit\u00b7e sur l'annonce.\",\n                    user_id=user.id,\n                )\n\n            logger.info(f\"User {user.id} registered to Game {locked_game.id}\")\n\n            # Add Discord role\n            self.discord.add_role_to_user(user.id, locked_game.role)\n            logger.info(f\"Role {locked_game.role} added to user {user.id}\")\n\n            # Send registration embed\n            self.discord.send_game_embed(locked_game, embed_type=\"register\", player=user.id)\n\n            return locked_game\n\n        except (DuplicateRegistrationError, GameFullError, GameClosedError):\n            db.session.rollback()\n            raise\n        except SQLAlchemyError:\n            db.session.rollback()\n            logger.exception(\"Failed to register user due to DB error.\")\n            raise\n\n    def unregister_player(self, slug: str, user_id: str) -&gt; Game:\n        \"\"\"Unregister a player from a game.\n\n        Args:\n            slug: Game slug.\n            user_id: User ID to unregister.\n\n        Returns:\n            Updated Game instance.\n\n        Raises:\n            NotFoundError: If game or user doesn't exist.\n            ValidationError: If user is not registered.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        user = self.user_service.get_by_id(user_id)\n\n        if user not in game.players:\n            raise ValidationError(\n                \"User is not registered for this game.\",\n                field=\"user_id\",\n            )\n\n        game.players.remove(user)\n\n        # Reopen if it was full\n        if (\n            game.status == \"closed\"\n            and len(game.players) &lt; game.party_size\n            and not game.party_selection\n        ):\n            game.status = \"open\"\n            log_game_event(\n                \"edit\",\n                game.id,\n                \"Annonce rouverte automatiquement apr\u00e8s d\u00e9sinscription.\",\n            )\n\n        db.session.commit()\n        logger.info(f\"User {user.id} removed from Game {game.id}\")\n\n        # Remove Discord role\n        self.discord.remove_role_from_user(user.id, game.role)\n        logger.info(f\"Role {game.role} removed from Player {user.id}\")\n\n        log_game_event(\n            \"unregister\",\n            game.id,\n            \"Le\u00b7a joueur\u00b7euse a \u00e9t\u00e9 d\u00e9sinscrit\u00b7e de l'annonce.\",\n            user_id=user.id,\n        )\n\n        return game\n\n    def clone(self, slug: str) -&gt; dict:\n        \"\"\"Clone a game (return data dict for form prefill).\n\n        Args:\n            slug: Game slug to clone.\n\n        Returns:\n            Dict with game data for form.\n\n        Raises:\n            NotFoundError: If game doesn't exist.\n        \"\"\"\n        game = self.get_by_slug(slug)\n        return game.to_dict(include_relationships=False)\n\n    def is_player(self, game: Game, user_id: str) -&gt; bool:\n        \"\"\"Check if a user is registered as a player in a game.\n\n        Args:\n            game: Game instance.\n            user_id: User ID to check.\n\n        Returns:\n            True if the user is a registered player.\n        \"\"\"\n        return any(p.id == user_id for p in game.players)\n\n    def search(\n        self,\n        filters: dict,\n        page: int = 1,\n        per_page: int = 20,\n        user_payload: Optional[dict] = None,\n    ) -&gt; tuple[list[Game], int]:\n        \"\"\"Search games with filters.\n\n        Args:\n            filters: Search filters dict.\n            page: Page number.\n            per_page: Items per page.\n            user_payload: User auth payload.\n\n        Returns:\n            Tuple of (games list, total count).\n        \"\"\"\n        return self.repo.search(filters, page, per_page, user_payload)\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.get_by_id","title":"<code>get_by_id(game_id)</code>","text":"<p>Get game by ID.</p> <p>Parameters:</p> Name Type Description Default <code>game_id</code> <code>int</code> <p>Game ID.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def get_by_id(self, game_id: int) -&gt; Game:\n    \"\"\"Get game by ID.\n\n    Args:\n        game_id: Game ID.\n\n    Returns:\n        Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.repo.get_by_id(game_id)\n    if not game:\n        raise NotFoundError(\n            f\"Game with id {game_id} not found\",\n            resource_type=\"Game\",\n            resource_id=game_id,\n        )\n    return game\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.get_by_slug","title":"<code>get_by_slug(slug)</code>","text":"<p>Get game by slug.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL-safe game identifier.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def get_by_slug(self, slug: str) -&gt; Game:\n    \"\"\"Get game by slug.\n\n    Args:\n        slug: URL-safe game identifier.\n\n    Returns:\n        Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.repo.get_by_slug(slug)\n    if not game:\n        raise NotFoundError(\n            f\"Game with slug '{slug}' not found\",\n            resource_type=\"Game\",\n            resource_id=slug,\n        )\n    return game\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.get_by_slug_or_404","title":"<code>get_by_slug_or_404(slug)</code>","text":"<p>Get game by slug or raise 404 (for Flask routes).</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>URL-safe game identifier.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>Game instance.</p> <p>Raises:</p> Type Description <code>NotFound</code> <p>Flask 404 error.</p> Source code in <code>website/services/game.py</code> <pre><code>def get_by_slug_or_404(self, slug: str) -&gt; Game:\n    \"\"\"Get game by slug or raise 404 (for Flask routes).\n\n    Args:\n        slug: URL-safe game identifier.\n\n    Returns:\n        Game instance.\n\n    Raises:\n        NotFound: Flask 404 error.\n    \"\"\"\n    return self.repo.get_by_slug_or_404(slug)\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.generate_slug","title":"<code>generate_slug(name, gm_name)</code>","text":"<p>Generate unique slug for a game.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Game name.</p> required <code>gm_name</code> <code>str</code> <p>GM stable username (preferred) or display name (fallback).</p> required <p>Returns:</p> Type Description <code>str</code> <p>Unique URL-safe slug.</p> Source code in <code>website/services/game.py</code> <pre><code>def generate_slug(self, name: str, gm_name: str) -&gt; str:\n    \"\"\"Generate unique slug for a game.\n\n    Args:\n        name: Game name.\n        gm_name: GM stable username (preferred) or display name (fallback).\n\n    Returns:\n        Unique URL-safe slug.\n    \"\"\"\n    existing_slugs = self.repo.get_all_slugs()\n    base_slug = slugify(f\"{name}-par-{gm_name}\")\n    slug = base_slug\n    i = 2\n    while slug in existing_slugs:\n        slug = f\"{base_slug}-{i}\"\n        i += 1\n    return slug\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.parse_game_type","title":"<code>parse_game_type(type_value)</code>","text":"<p>Parse game type value from form.</p> <p>Parameters:</p> Name Type Description Default <code>type_value</code> <code>str</code> <p>Type string, possibly \"specialevent-\". required <p>Returns:</p> Type Description <code>tuple[str, Optional[int]]</code> <p>Tuple of (game_type, special_event_id).</p> Source code in <code>website/services/game.py</code> <pre><code>def parse_game_type(self, type_value: str) -&gt; tuple[str, Optional[int]]:\n    \"\"\"Parse game type value from form.\n\n    Args:\n        type_value: Type string, possibly \"specialevent-&lt;id&gt;\".\n\n    Returns:\n        Tuple of (game_type, special_event_id).\n    \"\"\"\n    special_event_id = None\n    game_type = type_value\n\n    if type_value and type_value.startswith(\"specialevent-\"):\n        try:\n            special_event_id = int(type_value.split(\"-\", 1)[1])\n        except (ValueError, IndexError):\n            special_event_id = None\n        game_type = \"oneshot\"  # all special events are treated as oneshots\n\n    return game_type, special_event_id\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.create","title":"<code>create(data, gm_id, status='draft', create_resources=False)</code>","text":"<p>Create a new game.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>Game data dictionary from form.</p> required <code>gm_id</code> <code>str</code> <p>GM user ID.</p> required <code>status</code> <code>str</code> <p>Initial status (draft, open, closed).</p> <code>'draft'</code> <code>create_resources</code> <code>bool</code> <p>Whether to create Discord resources (role, channel).</p> <code>False</code> <p>Returns:</p> Type Description <code>Game</code> <p>Created Game instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If data is invalid.</p> <code>DiscordAPIError</code> <p>If Discord resource creation fails.</p> Source code in <code>website/services/game.py</code> <pre><code>def create(\n    self,\n    data: dict,\n    gm_id: str,\n    status: str = \"draft\",\n    create_resources: bool = False,\n) -&gt; Game:\n    \"\"\"Create a new game.\n\n    Args:\n        data: Game data dictionary from form.\n        gm_id: GM user ID.\n        status: Initial status (draft, open, closed).\n        create_resources: Whether to create Discord resources (role, channel).\n\n    Returns:\n        Created Game instance.\n\n    Raises:\n        ValidationError: If data is invalid.\n        DiscordAPIError: If Discord resource creation fails.\n    \"\"\"\n    from config.constants import DEFAULT_TIMEFORMAT\n    from website.utils.form_parsers import (\n        get_ambience,\n        get_classification,\n        parse_restriction_tags,\n    )\n\n    try:\n        # Parse special fields\n        game_type, special_event_id = self.parse_game_type(data[\"type\"])\n\n        # Get GM name for slug\n        gm = self.user_service.get_by_id(gm_id)\n\n        # Create game instance\n        game = Game(\n            name=data[\"name\"],\n            type=game_type,\n            special_event_id=special_event_id,\n            length=data[\"length\"],\n            gm_id=gm_id,\n            system_id=data[\"system\"],\n            vtt_id=data.get(\"vtt\") or None,\n            description=data[\"description\"],\n            restriction=data[\"restriction\"],\n            party_size=data[\"party_size\"],\n            xp=data[\"xp\"],\n            date=datetime.strptime(data[\"date\"], DEFAULT_TIMEFORMAT),\n            session_length=data[\"session_length\"],\n            frequency=data.get(\"frequency\") or None,\n            characters=data[\"characters\"],\n            classification=get_classification(),\n            ambience=get_ambience(data),\n            complement=data.get(\"complement\"),\n            status=status,\n            img=data.get(\"img\"),\n            party_selection=\"party_selection\" in data,\n            restriction_tags=parse_restriction_tags(data),\n        )\n\n        # Generate unique slug\n        game.slug = self.generate_slug(data[\"name\"], gm.slug_name)\n\n        # Add to session\n        self.repo.add(game)\n        db.session.flush()  # Ensure game.id is available\n\n        logger.info(f\"Game object created: {game.name} with slug {game.slug}\")\n\n        # Create Discord resources if requested\n        if create_resources:\n            self._setup_game_resources(game)\n            logger.info(\"Game post-creation setup completed.\")\n\n        db.session.commit()\n        log_game_event(\n            \"create\",\n            game.id,\n            f\"Annonce cr\u00e9\u00e9e avec le statut {game.status}.\",\n            user_id=game.gm_id,\n        )\n        logger.info(f\"Game saved in DB with ID: {game.id}\")\n\n        return game\n\n    except ValidationError:\n        db.session.rollback()\n        raise\n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Failed to create game: {e}\", exc_info=True)\n        # Rollback Discord resources if they were created\n        if create_resources and hasattr(game, \"role\"):\n            self._rollback_discord_resources(game)\n        raise\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.update","title":"<code>update(slug, data, user_id=None)</code>","text":"<p>Update an existing game.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>data</code> <code>dict</code> <p>Updated game data.</p> required <code>user_id</code> <code>str | None</code> <p>ID of the user performing the update.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Updated Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> <code>ValidationError</code> <p>If data is invalid.</p> Source code in <code>website/services/game.py</code> <pre><code>def update(self, slug: str, data: dict, user_id: str | None = None) -&gt; Game:\n    \"\"\"Update an existing game.\n\n    Args:\n        slug: Game slug.\n        data: Updated game data.\n        user_id: ID of the user performing the update.\n\n    Returns:\n        Updated Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n        ValidationError: If data is invalid.\n    \"\"\"\n    from config.constants import DEFAULT_TIMEFORMAT\n    from website.utils.form_parsers import (\n        get_ambience,\n        get_classification,\n        parse_restriction_tags,\n    )\n\n    game = self.get_by_slug(slug)\n\n    try:\n        # Only allow type/name changes if game is draft\n        if game.status == \"draft\":\n            game_type, special_event_id = self.parse_game_type(data[\"type\"])\n            game.type = game_type\n            game.special_event_id = special_event_id\n            game.name = data[\"name\"]\n\n        # Update fields\n        game.system_id = data[\"system\"]\n        game.vtt_id = data.get(\"vtt\") or None\n        game.description = data[\"description\"]\n        game.date = datetime.strptime(data[\"date\"], DEFAULT_TIMEFORMAT)\n        game.length = data[\"length\"]\n        game.party_size = data[\"party_size\"]\n        game.party_selection = \"party_selection\" in data\n        game.xp = data[\"xp\"]\n        game.session_length = data[\"session_length\"]\n        game.frequency = data.get(\"frequency\") or None\n        game.characters = data[\"characters\"]\n        game.classification = get_classification()\n        game.ambience = get_ambience(data)\n        game.complement = data.get(\"complement\")\n        game.img = data.get(\"img\")\n        game.restriction = data[\"restriction\"]\n        game.restriction_tags = parse_restriction_tags(data)\n\n        db.session.commit()\n        log_game_event(\n            \"edit\", game.id, \"Le contenu de l'annonce a \u00e9t\u00e9 \u00e9dit\u00e9.\", user_id=user_id\n        )\n        logger.info(f\"Game {game.id} changes saved\")\n\n        # Update Discord embed if message exists\n        if game.msg_id:\n            try:\n                self.discord.send_game_embed(game, embed_type=\"annonce\")\n                logger.info(f\"Embed updated for game {game.id}\")\n            except DiscordAPIError as e:\n                logger.warning(f\"Failed to update Discord embed for game {game.id}: {e}\")\n\n        return game\n\n    except ValidationError:\n        db.session.rollback()\n        raise\n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Failed to update game {game.id}: {e}\", exc_info=True)\n        raise\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.publish","title":"<code>publish(slug, silent=False, user_id=None)</code>","text":"<p>Publish a draft game to Discord.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>silent</code> <code>bool</code> <p>If True, don't send announcement (set to closed instead of open).</p> <code>False</code> <code>user_id</code> <code>str | None</code> <p>ID of the user performing the publish.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Published Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> <code>ValidationError</code> <p>If game is already published or is full.</p> <code>DiscordAPIError</code> <p>If Discord operations fail.</p> Source code in <code>website/services/game.py</code> <pre><code>def publish(self, slug: str, silent: bool = False, user_id: str | None = None) -&gt; Game:\n    \"\"\"Publish a draft game to Discord.\n\n    Args:\n        slug: Game slug.\n        silent: If True, don't send announcement (set to closed instead of open).\n        user_id: ID of the user performing the publish.\n\n    Returns:\n        Published Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n        ValidationError: If game is already published or is full.\n        DiscordAPIError: If Discord operations fail.\n    \"\"\"\n    game = self.get_by_slug(slug)\n\n    if game.msg_id:\n        raise ValidationError(\"Game is already published.\", field=\"status\")\n\n    if len(game.players) &gt;= game.party_size:\n        raise ValidationError(\"Cannot publish a full game.\", field=\"party_size\")\n\n    try:\n        game.status = \"closed\" if silent else \"open\"\n\n        # Set up resources if not already created\n        if not game.role or not game.channel:\n            self._setup_game_resources(game)\n\n        # Send Discord announcement if not silent\n        if not silent:\n            game.msg_id = self.discord.send_game_embed(game, embed_type=\"annonce\")\n            logger.info(f\"Discord embed sent with message ID: {game.msg_id}\")\n\n        db.session.commit()\n        log_game_event(\n            \"edit\",\n            game.id,\n            (\n                \"L'annonce a \u00e9t\u00e9 publi\u00e9e et ouverte.\"\n                if not silent\n                else \"L'annonce a \u00e9t\u00e9 ouverte silencieusement.\"\n            ),\n            user_id=user_id,\n        )\n        logger.info(\n            f\"Game {game.id} published and {'opened' if not silent else 'opened silently'}.\"\n        )\n\n        return game\n\n    except Exception as e:\n        db.session.rollback()\n        logger.error(f\"Failed to publish game {game.id}: {e}\", exc_info=True)\n        # Rollback Discord resources if they were just created\n        if not game.role or not game.channel:\n            self._rollback_discord_resources(game)\n        raise\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.close","title":"<code>close(slug, user_id=None)</code>","text":"<p>Close a game to new registrations.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>user_id</code> <code>str | None</code> <p>ID of the user performing the close.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Updated Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def close(self, slug: str, user_id: str | None = None) -&gt; Game:\n    \"\"\"Close a game to new registrations.\n\n    Args:\n        slug: Game slug.\n        user_id: ID of the user performing the close.\n\n    Returns:\n        Updated Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    game.status = \"closed\"\n\n    db.session.commit()\n    log_game_event(\n        \"edit\", game.id, \"Le statut de l'annonce \u00e0 chang\u00e9 en closed.\", user_id=user_id\n    )\n    logger.info(f\"Game status for {game.id} has been updated to closed\")\n\n    # Update Discord embed\n    if game.msg_id:\n        try:\n            self.discord.send_game_embed(game, embed_type=\"annonce\")\n            logger.info(f\"Embed updated due to status change for game {game.id}\")\n        except DiscordAPIError as e:\n            logger.warning(f\"Failed to update embed on status change for game {game.id}: {e}\")\n\n    return game\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.reopen","title":"<code>reopen(slug, user_id=None)</code>","text":"<p>Reopen a closed game.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>user_id</code> <code>str | None</code> <p>ID of the user performing the reopen.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Updated Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def reopen(self, slug: str, user_id: str | None = None) -&gt; Game:\n    \"\"\"Reopen a closed game.\n\n    Args:\n        slug: Game slug.\n        user_id: ID of the user performing the reopen.\n\n    Returns:\n        Updated Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    game.status = \"open\"\n\n    db.session.commit()\n    log_game_event(\n        \"edit\", game.id, \"Le statut de l'annonce \u00e0 chang\u00e9 en open.\", user_id=user_id\n    )\n    logger.info(f\"Game status for {game.id} has been updated to open\")\n\n    # Update Discord embed\n    if game.msg_id:\n        try:\n            self.discord.send_game_embed(game, embed_type=\"annonce\")\n            logger.info(f\"Embed updated due to status change for game {game.id}\")\n        except DiscordAPIError as e:\n            logger.warning(f\"Failed to update embed on status change for game {game.id}: {e}\")\n\n    return game\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.archive","title":"<code>archive(slug, award_trophies=True, user_id=None)</code>","text":"<p>Archive a game and clean up Discord resources.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>award_trophies</code> <code>bool</code> <p>Whether to award trophies to participants.</p> <code>True</code> <code>user_id</code> <code>str | None</code> <p>ID of the user performing the archive.</p> <code>None</code> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def archive(self, slug: str, award_trophies: bool = True, user_id: str | None = None) -&gt; None:\n    \"\"\"Archive a game and clean up Discord resources.\n\n    Args:\n        slug: Game slug.\n        award_trophies: Whether to award trophies to participants.\n        user_id: ID of the user performing the archive.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    game.status = \"archived\"\n\n    db.session.commit()\n    log_game_event(\n        \"edit\", game.id, \"Le statut de l'annonce \u00e0 chang\u00e9 en archived.\", user_id=user_id\n    )\n    logger.info(f\"Game status for {game.id} has been updated to archived\")\n\n    # Award trophies\n    msg = \"Annonce archiv\u00e9e.\"\n    if award_trophies:\n        self._award_game_trophies(game)\n        msg += \" Badges distribu\u00e9s.\"\n    else:\n        msg += \" Badges non-distribu\u00e9s.\"\n\n    # Clean up Discord resources\n    self._cleanup_discord_resources(game)\n    self._delete_game_message(game)\n\n    log_game_event(\"delete\", game.id, msg, user_id=user_id)\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.delete","title":"<code>delete(slug)</code>","text":"<p>Delete a game permanently.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def delete(self, slug: str) -&gt; None:\n    \"\"\"Delete a game permanently.\n\n    Args:\n        slug: Game slug.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    self.repo.delete_by_id(game.id)\n    db.session.commit()\n    logger.info(f\"Game {game.id} has been deleted.\")\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.register_player","title":"<code>register_player(slug, user_id, force=False)</code>","text":"<p>Register a player to a game (concurrent-safe).</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>user_id</code> <code>str</code> <p>User ID to register.</p> required <code>force</code> <code>bool</code> <p>If True, bypass capacity and status checks.</p> <code>False</code> <p>Returns:</p> Type Description <code>Game</code> <p>Updated Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> <code>DuplicateRegistrationError</code> <p>If user is already registered.</p> <code>GameFullError</code> <p>If game is at capacity and force is False.</p> <code>GameClosedError</code> <p>If game is closed and force is False.</p> Source code in <code>website/services/game.py</code> <pre><code>def register_player(self, slug: str, user_id: str, force: bool = False) -&gt; Game:\n    \"\"\"Register a player to a game (concurrent-safe).\n\n    Args:\n        slug: Game slug.\n        user_id: User ID to register.\n        force: If True, bypass capacity and status checks.\n\n    Returns:\n        Updated Game instance.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n        DuplicateRegistrationError: If user is already registered.\n        GameFullError: If game is at capacity and force is False.\n        GameClosedError: If game is closed and force is False.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    user = self.user_service.get_by_id(user_id)\n\n    try:\n        # Lock the game row for update\n        locked_game = self.repo.get_for_update(game.id)\n        if not locked_game:\n            raise NotFoundError(\n                f\"Game with id {game.id} not found\",\n                resource_type=\"Game\",\n                resource_id=game.id,\n            )\n\n        # Check if already registered\n        if user in locked_game.players:\n            raise DuplicateRegistrationError(\n                \"User is already registered for this game.\",\n                game_id=locked_game.id,\n                user_id=user.id,\n            )\n\n        # Check capacity\n        if len(locked_game.players) &gt;= locked_game.party_size and not force:\n            raise GameFullError(\n                \"Game is full.\",\n                game_id=locked_game.id,\n                max_players=locked_game.party_size,\n            )\n\n        # Check status\n        if locked_game.status == \"closed\" and not force:\n            raise GameClosedError(\n                \"Game is closed for registration.\",\n                game_id=locked_game.id,\n            )\n\n        # Add player\n        locked_game.players.append(user)\n\n        # Auto-close if full\n        if (\n            len(locked_game.players) &gt;= locked_game.party_size\n            and not locked_game.party_selection\n        ):\n            locked_game.status = \"closed\"\n            if locked_game.msg_id:\n                try:\n                    self.discord.send_game_embed(locked_game, embed_type=\"annonce\")\n                    logger.info(\n                        f\"Embed updated due to status change for game {locked_game.id}\"\n                    )\n                except DiscordAPIError as e:\n                    logger.warning(\n                        \"Failed to update embed on status change \"\n                        f\"for game {locked_game.id}: {e}\"\n                    )\n            log_game_event(\n                \"edit\",\n                locked_game.id,\n                \"Annonce ferm\u00e9e automatiquement apr\u00e8s avoir atteint le nombre \"\n                f\"max de joueur\u00b7euses ({locked_game.party_size}).\",\n            )\n            logger.info(f\"Game status for {locked_game.id} has been updated to closed\")\n\n        db.session.commit()\n\n        # Log event\n        if force:\n            log_game_event(\n                \"register\",\n                locked_game.id,\n                \"Le\u00b7a joueur\u00b7euse a \u00e9t\u00e9 ajout\u00e9\u00b7e \u00e0 la partie par le MJ.\",\n                user_id=user.id,\n            )\n        else:\n            log_game_event(\n                \"register\",\n                locked_game.id,\n                \"Le\u00b7a joueur\u00b7euse s'est inscrit\u00b7e sur l'annonce.\",\n                user_id=user.id,\n            )\n\n        logger.info(f\"User {user.id} registered to Game {locked_game.id}\")\n\n        # Add Discord role\n        self.discord.add_role_to_user(user.id, locked_game.role)\n        logger.info(f\"Role {locked_game.role} added to user {user.id}\")\n\n        # Send registration embed\n        self.discord.send_game_embed(locked_game, embed_type=\"register\", player=user.id)\n\n        return locked_game\n\n    except (DuplicateRegistrationError, GameFullError, GameClosedError):\n        db.session.rollback()\n        raise\n    except SQLAlchemyError:\n        db.session.rollback()\n        logger.exception(\"Failed to register user due to DB error.\")\n        raise\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.unregister_player","title":"<code>unregister_player(slug, user_id)</code>","text":"<p>Unregister a player from a game.</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug.</p> required <code>user_id</code> <code>str</code> <p>User ID to unregister.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>Updated Game instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game or user doesn't exist.</p> <code>ValidationError</code> <p>If user is not registered.</p> Source code in <code>website/services/game.py</code> <pre><code>def unregister_player(self, slug: str, user_id: str) -&gt; Game:\n    \"\"\"Unregister a player from a game.\n\n    Args:\n        slug: Game slug.\n        user_id: User ID to unregister.\n\n    Returns:\n        Updated Game instance.\n\n    Raises:\n        NotFoundError: If game or user doesn't exist.\n        ValidationError: If user is not registered.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    user = self.user_service.get_by_id(user_id)\n\n    if user not in game.players:\n        raise ValidationError(\n            \"User is not registered for this game.\",\n            field=\"user_id\",\n        )\n\n    game.players.remove(user)\n\n    # Reopen if it was full\n    if (\n        game.status == \"closed\"\n        and len(game.players) &lt; game.party_size\n        and not game.party_selection\n    ):\n        game.status = \"open\"\n        log_game_event(\n            \"edit\",\n            game.id,\n            \"Annonce rouverte automatiquement apr\u00e8s d\u00e9sinscription.\",\n        )\n\n    db.session.commit()\n    logger.info(f\"User {user.id} removed from Game {game.id}\")\n\n    # Remove Discord role\n    self.discord.remove_role_from_user(user.id, game.role)\n    logger.info(f\"Role {game.role} removed from Player {user.id}\")\n\n    log_game_event(\n        \"unregister\",\n        game.id,\n        \"Le\u00b7a joueur\u00b7euse a \u00e9t\u00e9 d\u00e9sinscrit\u00b7e de l'annonce.\",\n        user_id=user.id,\n    )\n\n    return game\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.clone","title":"<code>clone(slug)</code>","text":"<p>Clone a game (return data dict for form prefill).</p> <p>Parameters:</p> Name Type Description Default <code>slug</code> <code>str</code> <p>Game slug to clone.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with game data for form.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If game doesn't exist.</p> Source code in <code>website/services/game.py</code> <pre><code>def clone(self, slug: str) -&gt; dict:\n    \"\"\"Clone a game (return data dict for form prefill).\n\n    Args:\n        slug: Game slug to clone.\n\n    Returns:\n        Dict with game data for form.\n\n    Raises:\n        NotFoundError: If game doesn't exist.\n    \"\"\"\n    game = self.get_by_slug(slug)\n    return game.to_dict(include_relationships=False)\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.is_player","title":"<code>is_player(game, user_id)</code>","text":"<p>Check if a user is registered as a player in a game.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Game instance.</p> required <code>user_id</code> <code>str</code> <p>User ID to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the user is a registered player.</p> Source code in <code>website/services/game.py</code> <pre><code>def is_player(self, game: Game, user_id: str) -&gt; bool:\n    \"\"\"Check if a user is registered as a player in a game.\n\n    Args:\n        game: Game instance.\n        user_id: User ID to check.\n\n    Returns:\n        True if the user is a registered player.\n    \"\"\"\n    return any(p.id == user_id for p in game.players)\n</code></pre>"},{"location":"architecture/services/#website.services.GameService.search","title":"<code>search(filters, page=1, per_page=20, user_payload=None)</code>","text":"<p>Search games with filters.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>dict</code> <p>Search filters dict.</p> required <code>page</code> <code>int</code> <p>Page number.</p> <code>1</code> <code>per_page</code> <code>int</code> <p>Items per page.</p> <code>20</code> <code>user_payload</code> <code>Optional[dict]</code> <p>User auth payload.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[Game], int]</code> <p>Tuple of (games list, total count).</p> Source code in <code>website/services/game.py</code> <pre><code>def search(\n    self,\n    filters: dict,\n    page: int = 1,\n    per_page: int = 20,\n    user_payload: Optional[dict] = None,\n) -&gt; tuple[list[Game], int]:\n    \"\"\"Search games with filters.\n\n    Args:\n        filters: Search filters dict.\n        page: Page number.\n        per_page: Items per page.\n        user_payload: User auth payload.\n\n    Returns:\n        Tuple of (games list, total count).\n    \"\"\"\n    return self.repo.search(filters, page, per_page, user_payload)\n</code></pre>"},{"location":"architecture/services/#website.services.GameEventService","title":"<code>GameEventService</code>","text":"<p>Service layer for game event logging.</p> <p>Provides transaction-safe event recording for the game audit trail.</p> Source code in <code>website/services/game_event.py</code> <pre><code>class GameEventService:\n    \"\"\"Service layer for game event logging.\n\n    Provides transaction-safe event recording for the game audit trail.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or GameEventRepository()\n\n    def log_event(\n        self, action: str, game_id: int, description: str | None = None, user_id: str | None = None\n    ) -&gt; GameEvent:\n        \"\"\"Log a game event and commit the transaction.\n\n        Args:\n            action: Event action type (create, edit, delete, etc.).\n            game_id: ID of the related game.\n            description: Optional human-readable description.\n            user_id: Optional ID of the user that performed the action.\n\n        Returns:\n            Created GameEvent instance.\n        \"\"\"\n        event = self.repo.log(action, game_id, description, user_id)\n        db.session.commit()\n        return event\n</code></pre>"},{"location":"architecture/services/#website.services.GameEventService.log_event","title":"<code>log_event(action, game_id, description=None, user_id=None)</code>","text":"<p>Log a game event and commit the transaction.</p> <p>Parameters:</p> Name Type Description Default <code>action</code> <code>str</code> <p>Event action type (create, edit, delete, etc.).</p> required <code>game_id</code> <code>int</code> <p>ID of the related game.</p> required <code>description</code> <code>str | None</code> <p>Optional human-readable description.</p> <code>None</code> <code>user_id</code> <code>str | None</code> <p>Optional ID of the user that performed the action.</p> <code>None</code> <p>Returns:</p> Type Description <code>GameEvent</code> <p>Created GameEvent instance.</p> Source code in <code>website/services/game_event.py</code> <pre><code>def log_event(\n    self, action: str, game_id: int, description: str | None = None, user_id: str | None = None\n) -&gt; GameEvent:\n    \"\"\"Log a game event and commit the transaction.\n\n    Args:\n        action: Event action type (create, edit, delete, etc.).\n        game_id: ID of the related game.\n        description: Optional human-readable description.\n        user_id: Optional ID of the user that performed the action.\n\n    Returns:\n        Created GameEvent instance.\n    \"\"\"\n    event = self.repo.log(action, game_id, description, user_id)\n    db.session.commit()\n    return event\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService","title":"<code>GameSessionService</code>","text":"<p>Service layer for GameSession operations.</p> <p>Handles session creation, deletion, updates, and conflict detection.</p> Source code in <code>website/services/game_session.py</code> <pre><code>class GameSessionService:\n    \"\"\"Service layer for GameSession operations.\n\n    Handles session creation, deletion, updates, and conflict detection.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or GameSessionRepository()\n\n    def create(self, game: Game, start: datetime, end: datetime) -&gt; GameSession:\n        \"\"\"Create a new game session.\n\n        Args:\n            game: Game instance to add the session to.\n            start: Session start datetime.\n            end: Session end datetime.\n\n        Returns:\n            Created GameSession instance.\n\n        Raises:\n            ValidationError: If start &gt;= end.\n            SessionConflictError: If the session overlaps with an existing one.\n        \"\"\"\n        if start &gt;= end:\n            raise ValidationError(\"Session start must be before end time.\")\n\n        if self._has_conflict(game, start, end):\n            raise SessionConflictError(\n                \"Session overlaps with an existing session.\", game_id=game.id\n            )\n\n        session = GameSession(start=start, end=end)\n        self.repo.add(session)\n        game.sessions.append(session)\n        db.session.commit()\n        logger.info(f\"Session added for game {game.id} from {start} to {end}\")\n        return session\n\n    def delete(self, session: GameSession) -&gt; None:\n        \"\"\"Delete a game session.\n\n        Args:\n            session: GameSession instance to delete.\n        \"\"\"\n        game_id = session.game_id\n        start = session.start\n        end = session.end\n        self.repo.delete(session)\n        db.session.commit()\n        logger.info(f\"Session removed for game {game_id} from {start} to {end}\")\n\n    def update(self, session: GameSession, new_start: datetime, new_end: datetime) -&gt; GameSession:\n        \"\"\"Update a session's start/end times.\n\n        Args:\n            session: Existing GameSession instance.\n            new_start: New start datetime.\n            new_end: New end datetime.\n\n        Returns:\n            Updated GameSession instance.\n\n        Raises:\n            ValidationError: If new_start &gt;= new_end.\n            SessionConflictError: If new times overlap another session.\n        \"\"\"\n        if new_start &gt;= new_end:\n            raise ValidationError(\"Session start must be before end time.\")\n\n        game = session.game\n        if self._has_conflict(game, new_start, new_end, exclude_session_id=session.id):\n            raise SessionConflictError(\n                \"Session overlaps with an existing session.\", game_id=game.id\n            )\n\n        session.start = new_start\n        session.end = new_end\n        db.session.commit()\n        logger.info(f\"Session {session.id} updated to {new_start} - {new_end}\")\n        return session\n\n    def get_by_id_or_404(self, session_id: int) -&gt; GameSession:\n        \"\"\"Get session by ID or abort with 404.\n\n        Args:\n            session_id: Session ID.\n\n        Returns:\n            GameSession instance.\n\n        Raises:\n            NotFound: Flask 404 error.\n        \"\"\"\n        return self.repo.get_by_id_or_404(session_id)\n\n    def find_in_range(self, start: datetime, end: datetime) -&gt; list[GameSession]:\n        \"\"\"Find all sessions within a date range.\n\n        Args:\n            start: Range start datetime.\n            end: Range end datetime.\n\n        Returns:\n            List of GameSession instances within the range.\n        \"\"\"\n        return self.repo.find_in_range(start, end)\n\n    @cache.memoize(timeout=3600)\n    def get_stats_for_period(self, year: int | None, month: int | None) -&gt; dict:\n        \"\"\"Compute game statistics for a given month.\n\n        Aggregates session data into per-system, per-game counts for\n        oneshots and campaigns, along with GM participation.\n\n        Args:\n            year: Year to compute stats for, or None for current month.\n            month: Month to compute stats for, or None for current month.\n\n        Returns:\n            Dict with keys: base_day, last_day, num_os, num_campaign,\n            os_games, campaign_games, gm_names.\n        \"\"\"\n        if year and month:\n            base_day = datetime(year, month, 1)\n        else:\n            today = datetime.today()\n            base_day = today.replace(day=1)\n\n        last_day = datetime(\n            base_day.year,\n            base_day.month,\n            calendar.monthrange(base_day.year, base_day.month)[1],\n            23,\n            59,\n            59,\n            999999,\n        )\n\n        sessions = self.find_in_range(base_day, last_day)\n\n        num_os = 0\n        num_campaign = 0\n        os_games: dict = defaultdict(lambda: defaultdict(self._default_game_entry))\n        campaign_games: dict = defaultdict(lambda: defaultdict(self._default_game_entry))\n        gm_names: list[str] = []\n\n        for session in sessions:\n            game = session.game\n            system = game.system.name\n            slug = game.slug\n            entry = {\"name\": game.name, \"gm\": game.gm.name, \"count\": 1}\n\n            if game.type == \"oneshot\":\n                num_os += 1\n                if slug in os_games[system]:\n                    os_games[system][slug][\"count\"] += 1\n                else:\n                    os_games[system][slug] = entry\n            else:\n                num_campaign += 1\n                if slug in campaign_games[system]:\n                    campaign_games[system][slug][\"count\"] += 1\n                else:\n                    campaign_games[system][slug] = entry\n\n            gm_names.append(game.gm.name)\n\n        return {\n            \"base_day\": base_day,\n            \"last_day\": last_day,\n            \"num_os\": num_os,\n            \"num_campaign\": num_campaign,\n            \"os_games\": os_games,\n            \"campaign_games\": campaign_games,\n            \"gm_names\": gm_names,\n        }\n\n    @staticmethod\n    def _default_game_entry():\n        \"\"\"Return a default game entry dict for stats aggregation.\"\"\"\n        return {\"count\": 0, \"gm\": \"\"}\n\n    @staticmethod\n    def _has_conflict(game, start_dt, end_dt, exclude_session_id=None):\n        for s in game.sessions:\n            if exclude_session_id and s.id == exclude_session_id:\n                continue\n            if not (end_dt &lt;= s.start or start_dt &gt;= s.end):\n                return True\n        return False\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService.create","title":"<code>create(game, start, end)</code>","text":"<p>Create a new game session.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Game instance to add the session to.</p> required <code>start</code> <code>datetime</code> <p>Session start datetime.</p> required <code>end</code> <code>datetime</code> <p>Session end datetime.</p> required <p>Returns:</p> Type Description <code>GameSession</code> <p>Created GameSession instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If start &gt;= end.</p> <code>SessionConflictError</code> <p>If the session overlaps with an existing one.</p> Source code in <code>website/services/game_session.py</code> <pre><code>def create(self, game: Game, start: datetime, end: datetime) -&gt; GameSession:\n    \"\"\"Create a new game session.\n\n    Args:\n        game: Game instance to add the session to.\n        start: Session start datetime.\n        end: Session end datetime.\n\n    Returns:\n        Created GameSession instance.\n\n    Raises:\n        ValidationError: If start &gt;= end.\n        SessionConflictError: If the session overlaps with an existing one.\n    \"\"\"\n    if start &gt;= end:\n        raise ValidationError(\"Session start must be before end time.\")\n\n    if self._has_conflict(game, start, end):\n        raise SessionConflictError(\n            \"Session overlaps with an existing session.\", game_id=game.id\n        )\n\n    session = GameSession(start=start, end=end)\n    self.repo.add(session)\n    game.sessions.append(session)\n    db.session.commit()\n    logger.info(f\"Session added for game {game.id} from {start} to {end}\")\n    return session\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService.delete","title":"<code>delete(session)</code>","text":"<p>Delete a game session.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>GameSession</code> <p>GameSession instance to delete.</p> required Source code in <code>website/services/game_session.py</code> <pre><code>def delete(self, session: GameSession) -&gt; None:\n    \"\"\"Delete a game session.\n\n    Args:\n        session: GameSession instance to delete.\n    \"\"\"\n    game_id = session.game_id\n    start = session.start\n    end = session.end\n    self.repo.delete(session)\n    db.session.commit()\n    logger.info(f\"Session removed for game {game_id} from {start} to {end}\")\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService.update","title":"<code>update(session, new_start, new_end)</code>","text":"<p>Update a session's start/end times.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>GameSession</code> <p>Existing GameSession instance.</p> required <code>new_start</code> <code>datetime</code> <p>New start datetime.</p> required <code>new_end</code> <code>datetime</code> <p>New end datetime.</p> required <p>Returns:</p> Type Description <code>GameSession</code> <p>Updated GameSession instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If new_start &gt;= new_end.</p> <code>SessionConflictError</code> <p>If new times overlap another session.</p> Source code in <code>website/services/game_session.py</code> <pre><code>def update(self, session: GameSession, new_start: datetime, new_end: datetime) -&gt; GameSession:\n    \"\"\"Update a session's start/end times.\n\n    Args:\n        session: Existing GameSession instance.\n        new_start: New start datetime.\n        new_end: New end datetime.\n\n    Returns:\n        Updated GameSession instance.\n\n    Raises:\n        ValidationError: If new_start &gt;= new_end.\n        SessionConflictError: If new times overlap another session.\n    \"\"\"\n    if new_start &gt;= new_end:\n        raise ValidationError(\"Session start must be before end time.\")\n\n    game = session.game\n    if self._has_conflict(game, new_start, new_end, exclude_session_id=session.id):\n        raise SessionConflictError(\n            \"Session overlaps with an existing session.\", game_id=game.id\n        )\n\n    session.start = new_start\n    session.end = new_end\n    db.session.commit()\n    logger.info(f\"Session {session.id} updated to {new_start} - {new_end}\")\n    return session\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService.get_by_id_or_404","title":"<code>get_by_id_or_404(session_id)</code>","text":"<p>Get session by ID or abort with 404.</p> <p>Parameters:</p> Name Type Description Default <code>session_id</code> <code>int</code> <p>Session ID.</p> required <p>Returns:</p> Type Description <code>GameSession</code> <p>GameSession instance.</p> <p>Raises:</p> Type Description <code>NotFound</code> <p>Flask 404 error.</p> Source code in <code>website/services/game_session.py</code> <pre><code>def get_by_id_or_404(self, session_id: int) -&gt; GameSession:\n    \"\"\"Get session by ID or abort with 404.\n\n    Args:\n        session_id: Session ID.\n\n    Returns:\n        GameSession instance.\n\n    Raises:\n        NotFound: Flask 404 error.\n    \"\"\"\n    return self.repo.get_by_id_or_404(session_id)\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService.find_in_range","title":"<code>find_in_range(start, end)</code>","text":"<p>Find all sessions within a date range.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>datetime</code> <p>Range start datetime.</p> required <code>end</code> <code>datetime</code> <p>Range end datetime.</p> required <p>Returns:</p> Type Description <code>list[GameSession]</code> <p>List of GameSession instances within the range.</p> Source code in <code>website/services/game_session.py</code> <pre><code>def find_in_range(self, start: datetime, end: datetime) -&gt; list[GameSession]:\n    \"\"\"Find all sessions within a date range.\n\n    Args:\n        start: Range start datetime.\n        end: Range end datetime.\n\n    Returns:\n        List of GameSession instances within the range.\n    \"\"\"\n    return self.repo.find_in_range(start, end)\n</code></pre>"},{"location":"architecture/services/#website.services.GameSessionService.get_stats_for_period","title":"<code>get_stats_for_period(year, month)</code>","text":"<p>Compute game statistics for a given month.</p> <p>Aggregates session data into per-system, per-game counts for oneshots and campaigns, along with GM participation.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int | None</code> <p>Year to compute stats for, or None for current month.</p> required <code>month</code> <code>int | None</code> <p>Month to compute stats for, or None for current month.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dict with keys: base_day, last_day, num_os, num_campaign,</p> <code>dict</code> <p>os_games, campaign_games, gm_names.</p> Source code in <code>website/services/game_session.py</code> <pre><code>@cache.memoize(timeout=3600)\ndef get_stats_for_period(self, year: int | None, month: int | None) -&gt; dict:\n    \"\"\"Compute game statistics for a given month.\n\n    Aggregates session data into per-system, per-game counts for\n    oneshots and campaigns, along with GM participation.\n\n    Args:\n        year: Year to compute stats for, or None for current month.\n        month: Month to compute stats for, or None for current month.\n\n    Returns:\n        Dict with keys: base_day, last_day, num_os, num_campaign,\n        os_games, campaign_games, gm_names.\n    \"\"\"\n    if year and month:\n        base_day = datetime(year, month, 1)\n    else:\n        today = datetime.today()\n        base_day = today.replace(day=1)\n\n    last_day = datetime(\n        base_day.year,\n        base_day.month,\n        calendar.monthrange(base_day.year, base_day.month)[1],\n        23,\n        59,\n        59,\n        999999,\n    )\n\n    sessions = self.find_in_range(base_day, last_day)\n\n    num_os = 0\n    num_campaign = 0\n    os_games: dict = defaultdict(lambda: defaultdict(self._default_game_entry))\n    campaign_games: dict = defaultdict(lambda: defaultdict(self._default_game_entry))\n    gm_names: list[str] = []\n\n    for session in sessions:\n        game = session.game\n        system = game.system.name\n        slug = game.slug\n        entry = {\"name\": game.name, \"gm\": game.gm.name, \"count\": 1}\n\n        if game.type == \"oneshot\":\n            num_os += 1\n            if slug in os_games[system]:\n                os_games[system][slug][\"count\"] += 1\n            else:\n                os_games[system][slug] = entry\n        else:\n            num_campaign += 1\n            if slug in campaign_games[system]:\n                campaign_games[system][slug][\"count\"] += 1\n            else:\n                campaign_games[system][slug] = entry\n\n        gm_names.append(game.gm.name)\n\n    return {\n        \"base_day\": base_day,\n        \"last_day\": last_day,\n        \"num_os\": num_os,\n        \"num_campaign\": num_campaign,\n        \"os_games\": os_games,\n        \"campaign_games\": campaign_games,\n        \"gm_names\": gm_names,\n    }\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService","title":"<code>SpecialEventService</code>","text":"<p>Service layer for SpecialEvent business logic.</p> <p>Handles creation, updates, deletion, and retrieval of special events. Manages transaction boundaries and validation.</p> Source code in <code>website/services/special_event.py</code> <pre><code>class SpecialEventService:\n    \"\"\"Service layer for SpecialEvent business logic.\n\n    Handles creation, updates, deletion, and retrieval of special events.\n    Manages transaction boundaries and validation.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or SpecialEventRepository()\n\n    def get_all(self, active_only: bool = False) -&gt; list[SpecialEvent]:\n        \"\"\"Get all special events, optionally filtered by active status.\n\n        Args:\n            active_only: If True, only return active events. Defaults to False.\n\n        Returns:\n            List of SpecialEvent instances ordered by name.\n        \"\"\"\n        return self.repo.get_all(active_only=active_only)\n\n    def get_active(self) -&gt; list[SpecialEvent]:\n        \"\"\"Get all active special events.\n\n        Convenience method for dropdowns and context processors.\n\n        Returns:\n            List of active SpecialEvent instances ordered by name.\n        \"\"\"\n        return self.repo.get_active()\n\n    def get_by_id(self, id: int) -&gt; SpecialEvent:\n        \"\"\"Get special event by ID.\n\n        Args:\n            id: Special event ID.\n\n        Returns:\n            SpecialEvent instance.\n\n        Raises:\n            NotFoundError: If special event with given ID doesn't exist.\n        \"\"\"\n        event = self.repo.get_by_id(id)\n        if not event:\n            raise NotFoundError(\n                f\"SpecialEvent with id {id} not found\",\n                resource_type=\"SpecialEvent\",\n                resource_id=id,\n            )\n        return event\n\n    def create(\n        self, name: str, emoji: str = None, color: int = None, active: bool = False\n    ) -&gt; SpecialEvent:\n        \"\"\"Create a new special event.\n\n        Args:\n            name: Name of the special event (must be unique).\n            emoji: Optional emoji for the event.\n            color: Optional color as integer (e.g., 0xFF6600).\n            active: Whether the event is active. Defaults to False.\n\n        Returns:\n            Created SpecialEvent instance.\n\n        Raises:\n            ValidationError: If name already exists or validation fails.\n        \"\"\"\n        if self.repo.get_by_name(name):\n            raise ValidationError(\"Special event name already exists.\", field=\"name\")\n\n        event = SpecialEvent(name=name, emoji=emoji, color=color, active=active)\n        self.repo.add(event)\n        db.session.commit()\n        return event\n\n    def update(self, id: int, data: dict) -&gt; SpecialEvent:\n        \"\"\"Update special event.\n\n        Args:\n            id: Special event ID.\n            data: Dictionary of fields to update.\n\n        Returns:\n            Updated SpecialEvent instance.\n\n        Raises:\n            NotFoundError: If special event doesn't exist.\n            ValidationError: If name conflicts with existing event.\n        \"\"\"\n        event = self.repo.get_by_id_or_404(id)\n\n        # Check for name uniqueness if name is being changed\n        if \"name\" in data and data[\"name\"] != event.name:\n            existing = self.repo.get_by_name(data[\"name\"])\n            if existing:\n                raise ValidationError(\"Special event name already exists.\", field=\"name\")\n\n        event.update_from_dict(data)\n        db.session.commit()\n        return event\n\n    def delete(self, id: int) -&gt; None:\n        \"\"\"Delete special event.\n\n        Args:\n            id: Special event ID.\n\n        Raises:\n            NotFoundError: If special event doesn't exist.\n        \"\"\"\n        event = self.repo.get_by_id_or_404(id)\n        self.repo.delete(event)\n        db.session.commit()\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService.get_all","title":"<code>get_all(active_only=False)</code>","text":"<p>Get all special events, optionally filtered by active status.</p> <p>Parameters:</p> Name Type Description Default <code>active_only</code> <code>bool</code> <p>If True, only return active events. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[SpecialEvent]</code> <p>List of SpecialEvent instances ordered by name.</p> Source code in <code>website/services/special_event.py</code> <pre><code>def get_all(self, active_only: bool = False) -&gt; list[SpecialEvent]:\n    \"\"\"Get all special events, optionally filtered by active status.\n\n    Args:\n        active_only: If True, only return active events. Defaults to False.\n\n    Returns:\n        List of SpecialEvent instances ordered by name.\n    \"\"\"\n    return self.repo.get_all(active_only=active_only)\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService.get_active","title":"<code>get_active()</code>","text":"<p>Get all active special events.</p> <p>Convenience method for dropdowns and context processors.</p> <p>Returns:</p> Type Description <code>list[SpecialEvent]</code> <p>List of active SpecialEvent instances ordered by name.</p> Source code in <code>website/services/special_event.py</code> <pre><code>def get_active(self) -&gt; list[SpecialEvent]:\n    \"\"\"Get all active special events.\n\n    Convenience method for dropdowns and context processors.\n\n    Returns:\n        List of active SpecialEvent instances ordered by name.\n    \"\"\"\n    return self.repo.get_active()\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService.get_by_id","title":"<code>get_by_id(id)</code>","text":"<p>Get special event by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Special event ID.</p> required <p>Returns:</p> Type Description <code>SpecialEvent</code> <p>SpecialEvent instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If special event with given ID doesn't exist.</p> Source code in <code>website/services/special_event.py</code> <pre><code>def get_by_id(self, id: int) -&gt; SpecialEvent:\n    \"\"\"Get special event by ID.\n\n    Args:\n        id: Special event ID.\n\n    Returns:\n        SpecialEvent instance.\n\n    Raises:\n        NotFoundError: If special event with given ID doesn't exist.\n    \"\"\"\n    event = self.repo.get_by_id(id)\n    if not event:\n        raise NotFoundError(\n            f\"SpecialEvent with id {id} not found\",\n            resource_type=\"SpecialEvent\",\n            resource_id=id,\n        )\n    return event\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService.create","title":"<code>create(name, emoji=None, color=None, active=False)</code>","text":"<p>Create a new special event.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the special event (must be unique).</p> required <code>emoji</code> <code>str</code> <p>Optional emoji for the event.</p> <code>None</code> <code>color</code> <code>int</code> <p>Optional color as integer (e.g., 0xFF6600).</p> <code>None</code> <code>active</code> <code>bool</code> <p>Whether the event is active. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>SpecialEvent</code> <p>Created SpecialEvent instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If name already exists or validation fails.</p> Source code in <code>website/services/special_event.py</code> <pre><code>def create(\n    self, name: str, emoji: str = None, color: int = None, active: bool = False\n) -&gt; SpecialEvent:\n    \"\"\"Create a new special event.\n\n    Args:\n        name: Name of the special event (must be unique).\n        emoji: Optional emoji for the event.\n        color: Optional color as integer (e.g., 0xFF6600).\n        active: Whether the event is active. Defaults to False.\n\n    Returns:\n        Created SpecialEvent instance.\n\n    Raises:\n        ValidationError: If name already exists or validation fails.\n    \"\"\"\n    if self.repo.get_by_name(name):\n        raise ValidationError(\"Special event name already exists.\", field=\"name\")\n\n    event = SpecialEvent(name=name, emoji=emoji, color=color, active=active)\n    self.repo.add(event)\n    db.session.commit()\n    return event\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService.update","title":"<code>update(id, data)</code>","text":"<p>Update special event.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Special event ID.</p> required <code>data</code> <code>dict</code> <p>Dictionary of fields to update.</p> required <p>Returns:</p> Type Description <code>SpecialEvent</code> <p>Updated SpecialEvent instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If special event doesn't exist.</p> <code>ValidationError</code> <p>If name conflicts with existing event.</p> Source code in <code>website/services/special_event.py</code> <pre><code>def update(self, id: int, data: dict) -&gt; SpecialEvent:\n    \"\"\"Update special event.\n\n    Args:\n        id: Special event ID.\n        data: Dictionary of fields to update.\n\n    Returns:\n        Updated SpecialEvent instance.\n\n    Raises:\n        NotFoundError: If special event doesn't exist.\n        ValidationError: If name conflicts with existing event.\n    \"\"\"\n    event = self.repo.get_by_id_or_404(id)\n\n    # Check for name uniqueness if name is being changed\n    if \"name\" in data and data[\"name\"] != event.name:\n        existing = self.repo.get_by_name(data[\"name\"])\n        if existing:\n            raise ValidationError(\"Special event name already exists.\", field=\"name\")\n\n    event.update_from_dict(data)\n    db.session.commit()\n    return event\n</code></pre>"},{"location":"architecture/services/#website.services.SpecialEventService.delete","title":"<code>delete(id)</code>","text":"<p>Delete special event.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Special event ID.</p> required <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If special event doesn't exist.</p> Source code in <code>website/services/special_event.py</code> <pre><code>def delete(self, id: int) -&gt; None:\n    \"\"\"Delete special event.\n\n    Args:\n        id: Special event ID.\n\n    Raises:\n        NotFoundError: If special event doesn't exist.\n    \"\"\"\n    event = self.repo.get_by_id_or_404(id)\n    self.repo.delete(event)\n    db.session.commit()\n</code></pre>"},{"location":"architecture/services/#website.services.SystemService","title":"<code>SystemService</code>","text":"<p>Service layer for System (RPG game system) operations.</p> <p>Handles CRUD operations with cache invalidation.</p> Source code in <code>website/services/system.py</code> <pre><code>class SystemService:\n    \"\"\"Service layer for System (RPG game system) operations.\n\n    Handles CRUD operations with cache invalidation.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or SystemRepository()\n\n    @cache.memoize()\n    def get_all(self) -&gt; list[System]:\n        \"\"\"Get all systems ordered by name.\n\n        Returns:\n            List of System instances.\n        \"\"\"\n        return self.repo.get_all_ordered()\n\n    def get_by_id(self, id: int) -&gt; System:\n        \"\"\"Get system by ID.\n\n        Args:\n            id: System ID.\n\n        Returns:\n            System instance.\n\n        Raises:\n            NotFoundError: If system does not exist.\n        \"\"\"\n        system = self.repo.get_by_id(id)\n        if not system:\n            raise NotFoundError(\n                f\"System with id {id} not found\",\n                resource_type=\"System\",\n                resource_id=id,\n            )\n        return system\n\n    def create(self, name: str, icon: str = None) -&gt; System:\n        \"\"\"Create a new game system.\n\n        Args:\n            name: System name (must be unique).\n            icon: Optional icon path.\n\n        Returns:\n            Created System instance.\n\n        Raises:\n            ValidationError: If name already exists.\n        \"\"\"\n        if self.repo.get_by_name(name):\n            raise ValidationError(\"System name already exists.\", field=\"name\")\n        system = System(name=name, icon=icon)\n        self.repo.add(system)\n        db.session.commit()\n        cache.delete_memoized(self.get_all)\n        return system\n\n    def update(self, id: int, data: dict) -&gt; System:\n        \"\"\"Update an existing system.\n\n        Args:\n            id: System ID.\n            data: Dictionary of fields to update.\n\n        Returns:\n            Updated System instance.\n        \"\"\"\n        system = self.repo.get_by_id_or_404(id)\n        system.update_from_dict(data)\n        db.session.commit()\n        cache.delete_memoized(self.get_all)\n        return system\n\n    def delete(self, id: int) -&gt; None:\n        \"\"\"Delete a system.\n\n        Args:\n            id: System ID.\n        \"\"\"\n        system = self.repo.get_by_id_or_404(id)\n        self.repo.delete(system)\n        db.session.commit()\n        cache.delete_memoized(self.get_all)\n</code></pre>"},{"location":"architecture/services/#website.services.SystemService.get_all","title":"<code>get_all()</code>","text":"<p>Get all systems ordered by name.</p> <p>Returns:</p> Type Description <code>list[System]</code> <p>List of System instances.</p> Source code in <code>website/services/system.py</code> <pre><code>@cache.memoize()\ndef get_all(self) -&gt; list[System]:\n    \"\"\"Get all systems ordered by name.\n\n    Returns:\n        List of System instances.\n    \"\"\"\n    return self.repo.get_all_ordered()\n</code></pre>"},{"location":"architecture/services/#website.services.SystemService.get_by_id","title":"<code>get_by_id(id)</code>","text":"<p>Get system by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>System ID.</p> required <p>Returns:</p> Type Description <code>System</code> <p>System instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If system does not exist.</p> Source code in <code>website/services/system.py</code> <pre><code>def get_by_id(self, id: int) -&gt; System:\n    \"\"\"Get system by ID.\n\n    Args:\n        id: System ID.\n\n    Returns:\n        System instance.\n\n    Raises:\n        NotFoundError: If system does not exist.\n    \"\"\"\n    system = self.repo.get_by_id(id)\n    if not system:\n        raise NotFoundError(\n            f\"System with id {id} not found\",\n            resource_type=\"System\",\n            resource_id=id,\n        )\n    return system\n</code></pre>"},{"location":"architecture/services/#website.services.SystemService.create","title":"<code>create(name, icon=None)</code>","text":"<p>Create a new game system.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>System name (must be unique).</p> required <code>icon</code> <code>str</code> <p>Optional icon path.</p> <code>None</code> <p>Returns:</p> Type Description <code>System</code> <p>Created System instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If name already exists.</p> Source code in <code>website/services/system.py</code> <pre><code>def create(self, name: str, icon: str = None) -&gt; System:\n    \"\"\"Create a new game system.\n\n    Args:\n        name: System name (must be unique).\n        icon: Optional icon path.\n\n    Returns:\n        Created System instance.\n\n    Raises:\n        ValidationError: If name already exists.\n    \"\"\"\n    if self.repo.get_by_name(name):\n        raise ValidationError(\"System name already exists.\", field=\"name\")\n    system = System(name=name, icon=icon)\n    self.repo.add(system)\n    db.session.commit()\n    cache.delete_memoized(self.get_all)\n    return system\n</code></pre>"},{"location":"architecture/services/#website.services.SystemService.update","title":"<code>update(id, data)</code>","text":"<p>Update an existing system.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>System ID.</p> required <code>data</code> <code>dict</code> <p>Dictionary of fields to update.</p> required <p>Returns:</p> Type Description <code>System</code> <p>Updated System instance.</p> Source code in <code>website/services/system.py</code> <pre><code>def update(self, id: int, data: dict) -&gt; System:\n    \"\"\"Update an existing system.\n\n    Args:\n        id: System ID.\n        data: Dictionary of fields to update.\n\n    Returns:\n        Updated System instance.\n    \"\"\"\n    system = self.repo.get_by_id_or_404(id)\n    system.update_from_dict(data)\n    db.session.commit()\n    cache.delete_memoized(self.get_all)\n    return system\n</code></pre>"},{"location":"architecture/services/#website.services.SystemService.delete","title":"<code>delete(id)</code>","text":"<p>Delete a system.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>System ID.</p> required Source code in <code>website/services/system.py</code> <pre><code>def delete(self, id: int) -&gt; None:\n    \"\"\"Delete a system.\n\n    Args:\n        id: System ID.\n    \"\"\"\n    system = self.repo.get_by_id_or_404(id)\n    self.repo.delete(system)\n    db.session.commit()\n    cache.delete_memoized(self.get_all)\n</code></pre>"},{"location":"architecture/services/#website.services.TrophyService","title":"<code>TrophyService</code>","text":"<p>Service layer for Trophy business logic.</p> <p>Handles awarding trophies, leaderboards, and user badge retrieval. Manages transaction boundaries and trophy-specific business rules.</p> Source code in <code>website/services/trophy.py</code> <pre><code>class TrophyService:\n    \"\"\"Service layer for Trophy business logic.\n\n    Handles awarding trophies, leaderboards, and user badge retrieval.\n    Manages transaction boundaries and trophy-specific business rules.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or TrophyRepository()\n\n    def get_by_id(self, trophy_id: int) -&gt; Trophy:\n        \"\"\"Get trophy by ID.\n\n        Args:\n            trophy_id: Trophy ID.\n\n        Returns:\n            Trophy instance.\n\n        Raises:\n            NotFoundError: If trophy with given ID doesn't exist.\n        \"\"\"\n        trophy = self.repo.get_by_id(trophy_id)\n        if not trophy:\n            raise NotFoundError(\n                f\"Trophy with id {trophy_id} not found\",\n                resource_type=\"Trophy\",\n                resource_id=trophy_id,\n            )\n        return trophy\n\n    def get_all(self) -&gt; list[Trophy]:\n        \"\"\"Get all trophy definitions.\n\n        Returns:\n            List of all Trophy instances.\n        \"\"\"\n        return self.repo.get_all()\n\n    def award(self, user_id: str, trophy_id: int, amount: int = 1) -&gt; UserTrophy:\n        \"\"\"Award a trophy to a user.\n\n        Handles both unique and non-unique trophies according to business rules:\n        - Unique trophies: Only awarded once (quantity = 1), additional awards are ignored\n        - Non-unique trophies: Quantity is incremented by amount\n\n        Args:\n            user_id: User ID to award trophy to.\n            trophy_id: Trophy ID to award.\n            amount: Quantity to award (only applies to non-unique trophies). Defaults to 1.\n\n        Returns:\n            UserTrophy instance (created or updated).\n\n        Raises:\n            NotFoundError: If trophy doesn't exist.\n        \"\"\"\n        trophy = self.get_by_id(trophy_id)\n        user_trophy = self.repo.get_user_trophy(user_id, trophy_id)\n\n        if trophy.unique:\n            # Unique trophies: only award once\n            if user_trophy is None:\n                user_trophy = self.repo.award_trophy(user_id, trophy_id, amount=1)\n                logger.info(f\"User {user_id} got a trophy: {trophy.name}\")\n            else:\n                logger.debug(f\"User {user_id} already has unique trophy {trophy.name}, skipping\")\n        else:\n            # Non-unique trophies: increment quantity\n            user_trophy = self.repo.award_trophy(user_id, trophy_id, amount)\n            logger.info(f\"User {user_id} got a trophy: {trophy.name} (x{amount})\")\n\n        db.session.commit()\n        return user_trophy\n\n    def get_leaderboard(self, trophy_id: int, limit: int = 10) -&gt; list[tuple[User, int]]:\n        \"\"\"Get leaderboard for a specific trophy.\n\n        Args:\n            trophy_id: Trophy ID to get leaderboard for.\n            limit: Maximum number of entries to return. Defaults to 10.\n\n        Returns:\n            List of (User, total_quantity) tuples ordered by quantity descending.\n\n        Raises:\n            NotFoundError: If trophy doesn't exist.\n        \"\"\"\n        # Verify trophy exists\n        self.get_by_id(trophy_id)\n        return self.repo.get_leaderboard(trophy_id, limit)\n\n    def get_user_badges(self, user_id: str) -&gt; list[dict]:\n        \"\"\"Get all trophies/badges for a user.\n\n        Args:\n            user_id: User ID.\n\n        Returns:\n            List of dicts with keys: name, icon, quantity.\n        \"\"\"\n        user_trophies = (\n            self.repo.session.query(UserTrophy).filter_by(user_id=user_id).join(Trophy).all()\n        )\n\n        return [\n            {\n                \"name\": ut.trophy.name,\n                \"icon\": ut.trophy.icon,\n                \"quantity\": ut.quantity,\n            }\n            for ut in user_trophies\n        ]\n</code></pre>"},{"location":"architecture/services/#website.services.TrophyService.get_by_id","title":"<code>get_by_id(trophy_id)</code>","text":"<p>Get trophy by ID.</p> <p>Parameters:</p> Name Type Description Default <code>trophy_id</code> <code>int</code> <p>Trophy ID.</p> required <p>Returns:</p> Type Description <code>Trophy</code> <p>Trophy instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If trophy with given ID doesn't exist.</p> Source code in <code>website/services/trophy.py</code> <pre><code>def get_by_id(self, trophy_id: int) -&gt; Trophy:\n    \"\"\"Get trophy by ID.\n\n    Args:\n        trophy_id: Trophy ID.\n\n    Returns:\n        Trophy instance.\n\n    Raises:\n        NotFoundError: If trophy with given ID doesn't exist.\n    \"\"\"\n    trophy = self.repo.get_by_id(trophy_id)\n    if not trophy:\n        raise NotFoundError(\n            f\"Trophy with id {trophy_id} not found\",\n            resource_type=\"Trophy\",\n            resource_id=trophy_id,\n        )\n    return trophy\n</code></pre>"},{"location":"architecture/services/#website.services.TrophyService.get_all","title":"<code>get_all()</code>","text":"<p>Get all trophy definitions.</p> <p>Returns:</p> Type Description <code>list[Trophy]</code> <p>List of all Trophy instances.</p> Source code in <code>website/services/trophy.py</code> <pre><code>def get_all(self) -&gt; list[Trophy]:\n    \"\"\"Get all trophy definitions.\n\n    Returns:\n        List of all Trophy instances.\n    \"\"\"\n    return self.repo.get_all()\n</code></pre>"},{"location":"architecture/services/#website.services.TrophyService.award","title":"<code>award(user_id, trophy_id, amount=1)</code>","text":"<p>Award a trophy to a user.</p> <p>Handles both unique and non-unique trophies according to business rules: - Unique trophies: Only awarded once (quantity = 1), additional awards are ignored - Non-unique trophies: Quantity is incremented by amount</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID to award trophy to.</p> required <code>trophy_id</code> <code>int</code> <p>Trophy ID to award.</p> required <code>amount</code> <code>int</code> <p>Quantity to award (only applies to non-unique trophies). Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>UserTrophy</code> <p>UserTrophy instance (created or updated).</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If trophy doesn't exist.</p> Source code in <code>website/services/trophy.py</code> <pre><code>def award(self, user_id: str, trophy_id: int, amount: int = 1) -&gt; UserTrophy:\n    \"\"\"Award a trophy to a user.\n\n    Handles both unique and non-unique trophies according to business rules:\n    - Unique trophies: Only awarded once (quantity = 1), additional awards are ignored\n    - Non-unique trophies: Quantity is incremented by amount\n\n    Args:\n        user_id: User ID to award trophy to.\n        trophy_id: Trophy ID to award.\n        amount: Quantity to award (only applies to non-unique trophies). Defaults to 1.\n\n    Returns:\n        UserTrophy instance (created or updated).\n\n    Raises:\n        NotFoundError: If trophy doesn't exist.\n    \"\"\"\n    trophy = self.get_by_id(trophy_id)\n    user_trophy = self.repo.get_user_trophy(user_id, trophy_id)\n\n    if trophy.unique:\n        # Unique trophies: only award once\n        if user_trophy is None:\n            user_trophy = self.repo.award_trophy(user_id, trophy_id, amount=1)\n            logger.info(f\"User {user_id} got a trophy: {trophy.name}\")\n        else:\n            logger.debug(f\"User {user_id} already has unique trophy {trophy.name}, skipping\")\n    else:\n        # Non-unique trophies: increment quantity\n        user_trophy = self.repo.award_trophy(user_id, trophy_id, amount)\n        logger.info(f\"User {user_id} got a trophy: {trophy.name} (x{amount})\")\n\n    db.session.commit()\n    return user_trophy\n</code></pre>"},{"location":"architecture/services/#website.services.TrophyService.get_leaderboard","title":"<code>get_leaderboard(trophy_id, limit=10)</code>","text":"<p>Get leaderboard for a specific trophy.</p> <p>Parameters:</p> Name Type Description Default <code>trophy_id</code> <code>int</code> <p>Trophy ID to get leaderboard for.</p> required <code>limit</code> <code>int</code> <p>Maximum number of entries to return. Defaults to 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[tuple[User, int]]</code> <p>List of (User, total_quantity) tuples ordered by quantity descending.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If trophy doesn't exist.</p> Source code in <code>website/services/trophy.py</code> <pre><code>def get_leaderboard(self, trophy_id: int, limit: int = 10) -&gt; list[tuple[User, int]]:\n    \"\"\"Get leaderboard for a specific trophy.\n\n    Args:\n        trophy_id: Trophy ID to get leaderboard for.\n        limit: Maximum number of entries to return. Defaults to 10.\n\n    Returns:\n        List of (User, total_quantity) tuples ordered by quantity descending.\n\n    Raises:\n        NotFoundError: If trophy doesn't exist.\n    \"\"\"\n    # Verify trophy exists\n    self.get_by_id(trophy_id)\n    return self.repo.get_leaderboard(trophy_id, limit)\n</code></pre>"},{"location":"architecture/services/#website.services.TrophyService.get_user_badges","title":"<code>get_user_badges(user_id)</code>","text":"<p>Get all trophies/badges for a user.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>User ID.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>List of dicts with keys: name, icon, quantity.</p> Source code in <code>website/services/trophy.py</code> <pre><code>def get_user_badges(self, user_id: str) -&gt; list[dict]:\n    \"\"\"Get all trophies/badges for a user.\n\n    Args:\n        user_id: User ID.\n\n    Returns:\n        List of dicts with keys: name, icon, quantity.\n    \"\"\"\n    user_trophies = (\n        self.repo.session.query(UserTrophy).filter_by(user_id=user_id).join(Trophy).all()\n    )\n\n    return [\n        {\n            \"name\": ut.trophy.name,\n            \"icon\": ut.trophy.icon,\n            \"quantity\": ut.quantity,\n        }\n        for ut in user_trophies\n    ]\n</code></pre>"},{"location":"architecture/services/#website.services.UserService","title":"<code>UserService</code>","text":"<p>Service layer for User operations.</p> <p>Handles user retrieval, creation, and Discord profile management.</p> Source code in <code>website/services/user.py</code> <pre><code>class UserService:\n    \"\"\"Service layer for User operations.\n\n    Handles user retrieval, creation, and Discord profile management.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or UserRepository()\n\n    def get_by_id(self, user_id: str) -&gt; User:\n        \"\"\"Get user by ID.\n\n        Args:\n            user_id: Discord user ID.\n\n        Returns:\n            User instance.\n\n        Raises:\n            NotFoundError: If user does not exist.\n        \"\"\"\n        user = self.repo.get_by_id(user_id)\n        if not user:\n            raise NotFoundError(\n                f\"User with id {user_id} not found\",\n                resource_type=\"User\",\n                resource_id=user_id,\n            )\n        return user\n\n    def get_or_create(\n        self, user_id: str, name: str = \"Inconnu\", username: str | None = None\n    ) -&gt; tuple[User, bool]:\n        \"\"\"Get an existing user or create a new one.\n\n        Args:\n            user_id: Discord user ID.\n            name: Display name for new users. Defaults to 'Inconnu'.\n            username: Stable Discord username (optional).\n\n        Returns:\n            Tuple of (User, created) where created is True if the user was new.\n        \"\"\"\n        user = self.repo.get_by_id(user_id)\n        if user:\n            return user, False\n        user = User(id=user_id, name=name, username=username)\n        self.repo.add(user)\n        db.session.commit()\n        user.init_on_load()\n        return user, True\n\n    def get_all(self) -&gt; list[User]:\n        \"\"\"Get all users.\n\n        Returns:\n            List of all User instances.\n        \"\"\"\n        return self.repo.get_all()\n\n    def get_active_users(self) -&gt; list[User]:\n        \"\"\"Get all users not marked as inactive.\n\n        Returns:\n            List of active User instances.\n        \"\"\"\n        return self.repo.get_active_users()\n\n    def get_active_user_ids(self) -&gt; list[str]:\n        \"\"\"Get IDs of all users not marked as inactive.\n\n        Lightweight query that avoids loading full ORM objects.\n\n        Returns:\n            List of active user ID strings.\n        \"\"\"\n        return self.repo.get_active_user_ids()\n\n    def get_inactive_users(self) -&gt; list[User]:\n        \"\"\"Get all users marked as inactive.\n\n        Returns:\n            List of inactive User instances.\n        \"\"\"\n        return self.repo.get_inactive_users()\n\n    def get_inactive_user_ids(self) -&gt; list[str]:\n        \"\"\"Get IDs of all users marked as inactive.\n\n        Lightweight query that avoids loading full ORM objects.\n\n        Returns:\n            List of inactive user ID strings.\n        \"\"\"\n        return self.repo.get_inactive_user_ids()\n\n    def get_by_ids(self, ids: list[str]) -&gt; list[User]:\n        \"\"\"Get users by a list of IDs.\n\n        Args:\n            ids: List of user ID strings.\n\n        Returns:\n            List of User instances matching the given IDs.\n        \"\"\"\n        return self.repo.get_by_ids(ids)\n\n    @staticmethod\n    def get_user_profile(user_id: str, force_refresh: bool = False) -&gt; dict:\n        \"\"\"Fetch a user's Discord profile.\n\n        Args:\n            user_id: Discord user ID.\n            force_refresh: If True, bypass cache and fetch from Discord.\n\n        Returns:\n            Dict with 'name', 'avatar', and optionally 'not_found' keys.\n        \"\"\"\n        return _get_user_profile(user_id, force_refresh=force_refresh)\n\n    def mark_inactive(self, user_id: str) -&gt; User:\n        \"\"\"Mark a user as inactive (left the Discord server).\n\n        Args:\n            user_id: Discord user ID.\n\n        Returns:\n            Updated User instance.\n\n        Raises:\n            NotFoundError: If user does not exist.\n        \"\"\"\n        user = self.get_by_id(user_id)\n        user.not_player_as_of = datetime.now(timezone.utc)\n        db.session.commit()\n        return user\n\n    def clear_inactive(self, user_id: str) -&gt; User:\n        \"\"\"Clear the inactive flag for a user (they have rejoined).\n\n        Args:\n            user_id: Discord user ID.\n\n        Returns:\n            Updated User instance.\n\n        Raises:\n            NotFoundError: If user does not exist.\n        \"\"\"\n        user = self.get_by_id(user_id)\n        user.not_player_as_of = None\n        db.session.commit()\n        return user\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_by_id","title":"<code>get_by_id(user_id)</code>","text":"<p>Get user by ID.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <p>Returns:</p> Type Description <code>User</code> <p>User instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If user does not exist.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_by_id(self, user_id: str) -&gt; User:\n    \"\"\"Get user by ID.\n\n    Args:\n        user_id: Discord user ID.\n\n    Returns:\n        User instance.\n\n    Raises:\n        NotFoundError: If user does not exist.\n    \"\"\"\n    user = self.repo.get_by_id(user_id)\n    if not user:\n        raise NotFoundError(\n            f\"User with id {user_id} not found\",\n            resource_type=\"User\",\n            resource_id=user_id,\n        )\n    return user\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_or_create","title":"<code>get_or_create(user_id, name='Inconnu', username=None)</code>","text":"<p>Get an existing user or create a new one.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <code>name</code> <code>str</code> <p>Display name for new users. Defaults to 'Inconnu'.</p> <code>'Inconnu'</code> <code>username</code> <code>str | None</code> <p>Stable Discord username (optional).</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[User, bool]</code> <p>Tuple of (User, created) where created is True if the user was new.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_or_create(\n    self, user_id: str, name: str = \"Inconnu\", username: str | None = None\n) -&gt; tuple[User, bool]:\n    \"\"\"Get an existing user or create a new one.\n\n    Args:\n        user_id: Discord user ID.\n        name: Display name for new users. Defaults to 'Inconnu'.\n        username: Stable Discord username (optional).\n\n    Returns:\n        Tuple of (User, created) where created is True if the user was new.\n    \"\"\"\n    user = self.repo.get_by_id(user_id)\n    if user:\n        return user, False\n    user = User(id=user_id, name=name, username=username)\n    self.repo.add(user)\n    db.session.commit()\n    user.init_on_load()\n    return user, True\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_all","title":"<code>get_all()</code>","text":"<p>Get all users.</p> <p>Returns:</p> Type Description <code>list[User]</code> <p>List of all User instances.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_all(self) -&gt; list[User]:\n    \"\"\"Get all users.\n\n    Returns:\n        List of all User instances.\n    \"\"\"\n    return self.repo.get_all()\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_active_users","title":"<code>get_active_users()</code>","text":"<p>Get all users not marked as inactive.</p> <p>Returns:</p> Type Description <code>list[User]</code> <p>List of active User instances.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_active_users(self) -&gt; list[User]:\n    \"\"\"Get all users not marked as inactive.\n\n    Returns:\n        List of active User instances.\n    \"\"\"\n    return self.repo.get_active_users()\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_active_user_ids","title":"<code>get_active_user_ids()</code>","text":"<p>Get IDs of all users not marked as inactive.</p> <p>Lightweight query that avoids loading full ORM objects.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of active user ID strings.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_active_user_ids(self) -&gt; list[str]:\n    \"\"\"Get IDs of all users not marked as inactive.\n\n    Lightweight query that avoids loading full ORM objects.\n\n    Returns:\n        List of active user ID strings.\n    \"\"\"\n    return self.repo.get_active_user_ids()\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_inactive_users","title":"<code>get_inactive_users()</code>","text":"<p>Get all users marked as inactive.</p> <p>Returns:</p> Type Description <code>list[User]</code> <p>List of inactive User instances.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_inactive_users(self) -&gt; list[User]:\n    \"\"\"Get all users marked as inactive.\n\n    Returns:\n        List of inactive User instances.\n    \"\"\"\n    return self.repo.get_inactive_users()\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_inactive_user_ids","title":"<code>get_inactive_user_ids()</code>","text":"<p>Get IDs of all users marked as inactive.</p> <p>Lightweight query that avoids loading full ORM objects.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of inactive user ID strings.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_inactive_user_ids(self) -&gt; list[str]:\n    \"\"\"Get IDs of all users marked as inactive.\n\n    Lightweight query that avoids loading full ORM objects.\n\n    Returns:\n        List of inactive user ID strings.\n    \"\"\"\n    return self.repo.get_inactive_user_ids()\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_by_ids","title":"<code>get_by_ids(ids)</code>","text":"<p>Get users by a list of IDs.</p> <p>Parameters:</p> Name Type Description Default <code>ids</code> <code>list[str]</code> <p>List of user ID strings.</p> required <p>Returns:</p> Type Description <code>list[User]</code> <p>List of User instances matching the given IDs.</p> Source code in <code>website/services/user.py</code> <pre><code>def get_by_ids(self, ids: list[str]) -&gt; list[User]:\n    \"\"\"Get users by a list of IDs.\n\n    Args:\n        ids: List of user ID strings.\n\n    Returns:\n        List of User instances matching the given IDs.\n    \"\"\"\n    return self.repo.get_by_ids(ids)\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.get_user_profile","title":"<code>get_user_profile(user_id, force_refresh=False)</code>  <code>staticmethod</code>","text":"<p>Fetch a user's Discord profile.</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <code>force_refresh</code> <code>bool</code> <p>If True, bypass cache and fetch from Discord.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dict with 'name', 'avatar', and optionally 'not_found' keys.</p> Source code in <code>website/services/user.py</code> <pre><code>@staticmethod\ndef get_user_profile(user_id: str, force_refresh: bool = False) -&gt; dict:\n    \"\"\"Fetch a user's Discord profile.\n\n    Args:\n        user_id: Discord user ID.\n        force_refresh: If True, bypass cache and fetch from Discord.\n\n    Returns:\n        Dict with 'name', 'avatar', and optionally 'not_found' keys.\n    \"\"\"\n    return _get_user_profile(user_id, force_refresh=force_refresh)\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.mark_inactive","title":"<code>mark_inactive(user_id)</code>","text":"<p>Mark a user as inactive (left the Discord server).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <p>Returns:</p> Type Description <code>User</code> <p>Updated User instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If user does not exist.</p> Source code in <code>website/services/user.py</code> <pre><code>def mark_inactive(self, user_id: str) -&gt; User:\n    \"\"\"Mark a user as inactive (left the Discord server).\n\n    Args:\n        user_id: Discord user ID.\n\n    Returns:\n        Updated User instance.\n\n    Raises:\n        NotFoundError: If user does not exist.\n    \"\"\"\n    user = self.get_by_id(user_id)\n    user.not_player_as_of = datetime.now(timezone.utc)\n    db.session.commit()\n    return user\n</code></pre>"},{"location":"architecture/services/#website.services.UserService.clear_inactive","title":"<code>clear_inactive(user_id)</code>","text":"<p>Clear the inactive flag for a user (they have rejoined).</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>str</code> <p>Discord user ID.</p> required <p>Returns:</p> Type Description <code>User</code> <p>Updated User instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If user does not exist.</p> Source code in <code>website/services/user.py</code> <pre><code>def clear_inactive(self, user_id: str) -&gt; User:\n    \"\"\"Clear the inactive flag for a user (they have rejoined).\n\n    Args:\n        user_id: Discord user ID.\n\n    Returns:\n        Updated User instance.\n\n    Raises:\n        NotFoundError: If user does not exist.\n    \"\"\"\n    user = self.get_by_id(user_id)\n    user.not_player_as_of = None\n    db.session.commit()\n    return user\n</code></pre>"},{"location":"architecture/services/#website.services.VttService","title":"<code>VttService</code>","text":"<p>Service layer for Vtt (virtual tabletop) operations.</p> <p>Handles CRUD operations with cache invalidation.</p> Source code in <code>website/services/vtt.py</code> <pre><code>class VttService:\n    \"\"\"Service layer for Vtt (virtual tabletop) operations.\n\n    Handles CRUD operations with cache invalidation.\n    \"\"\"\n\n    def __init__(self, repository=None):\n        self.repo = repository or VttRepository()\n\n    @cache.memoize()\n    def get_all(self) -&gt; list[Vtt]:\n        \"\"\"Get all VTTs ordered by name.\n\n        Returns:\n            List of Vtt instances.\n        \"\"\"\n        return self.repo.get_all_ordered()\n\n    def get_by_id(self, id: int) -&gt; Vtt:\n        \"\"\"Get VTT by ID.\n\n        Args:\n            id: VTT ID.\n\n        Returns:\n            Vtt instance.\n\n        Raises:\n            NotFoundError: If VTT does not exist.\n        \"\"\"\n        vtt = self.repo.get_by_id(id)\n        if not vtt:\n            raise NotFoundError(\n                f\"Vtt with id {id} not found\",\n                resource_type=\"Vtt\",\n                resource_id=id,\n            )\n        return vtt\n\n    def create(self, name: str, icon: str = None) -&gt; Vtt:\n        \"\"\"Create a new VTT.\n\n        Args:\n            name: VTT name (must be unique).\n            icon: Optional icon path.\n\n        Returns:\n            Created Vtt instance.\n\n        Raises:\n            ValidationError: If name already exists.\n        \"\"\"\n        if self.repo.get_by_name(name):\n            raise ValidationError(\"Vtt name already exists.\", field=\"name\")\n        vtt = Vtt(name=name, icon=icon)\n        self.repo.add(vtt)\n        db.session.commit()\n        cache.delete_memoized(self.get_all)\n        return vtt\n\n    def update(self, id: int, data: dict) -&gt; Vtt:\n        \"\"\"Update an existing VTT.\n\n        Args:\n            id: VTT ID.\n            data: Dictionary of fields to update.\n\n        Returns:\n            Updated Vtt instance.\n        \"\"\"\n        vtt = self.repo.get_by_id_or_404(id)\n        vtt.update_from_dict(data)\n        db.session.commit()\n        cache.delete_memoized(self.get_all)\n        return vtt\n\n    def delete(self, id: int) -&gt; None:\n        \"\"\"Delete a VTT.\n\n        Args:\n            id: VTT ID.\n        \"\"\"\n        vtt = self.repo.get_by_id_or_404(id)\n        self.repo.delete(vtt)\n        db.session.commit()\n        cache.delete_memoized(self.get_all)\n</code></pre>"},{"location":"architecture/services/#website.services.VttService.get_all","title":"<code>get_all()</code>","text":"<p>Get all VTTs ordered by name.</p> <p>Returns:</p> Type Description <code>list[Vtt]</code> <p>List of Vtt instances.</p> Source code in <code>website/services/vtt.py</code> <pre><code>@cache.memoize()\ndef get_all(self) -&gt; list[Vtt]:\n    \"\"\"Get all VTTs ordered by name.\n\n    Returns:\n        List of Vtt instances.\n    \"\"\"\n    return self.repo.get_all_ordered()\n</code></pre>"},{"location":"architecture/services/#website.services.VttService.get_by_id","title":"<code>get_by_id(id)</code>","text":"<p>Get VTT by ID.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>VTT ID.</p> required <p>Returns:</p> Type Description <code>Vtt</code> <p>Vtt instance.</p> <p>Raises:</p> Type Description <code>NotFoundError</code> <p>If VTT does not exist.</p> Source code in <code>website/services/vtt.py</code> <pre><code>def get_by_id(self, id: int) -&gt; Vtt:\n    \"\"\"Get VTT by ID.\n\n    Args:\n        id: VTT ID.\n\n    Returns:\n        Vtt instance.\n\n    Raises:\n        NotFoundError: If VTT does not exist.\n    \"\"\"\n    vtt = self.repo.get_by_id(id)\n    if not vtt:\n        raise NotFoundError(\n            f\"Vtt with id {id} not found\",\n            resource_type=\"Vtt\",\n            resource_id=id,\n        )\n    return vtt\n</code></pre>"},{"location":"architecture/services/#website.services.VttService.create","title":"<code>create(name, icon=None)</code>","text":"<p>Create a new VTT.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>VTT name (must be unique).</p> required <code>icon</code> <code>str</code> <p>Optional icon path.</p> <code>None</code> <p>Returns:</p> Type Description <code>Vtt</code> <p>Created Vtt instance.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If name already exists.</p> Source code in <code>website/services/vtt.py</code> <pre><code>def create(self, name: str, icon: str = None) -&gt; Vtt:\n    \"\"\"Create a new VTT.\n\n    Args:\n        name: VTT name (must be unique).\n        icon: Optional icon path.\n\n    Returns:\n        Created Vtt instance.\n\n    Raises:\n        ValidationError: If name already exists.\n    \"\"\"\n    if self.repo.get_by_name(name):\n        raise ValidationError(\"Vtt name already exists.\", field=\"name\")\n    vtt = Vtt(name=name, icon=icon)\n    self.repo.add(vtt)\n    db.session.commit()\n    cache.delete_memoized(self.get_all)\n    return vtt\n</code></pre>"},{"location":"architecture/services/#website.services.VttService.update","title":"<code>update(id, data)</code>","text":"<p>Update an existing VTT.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>VTT ID.</p> required <code>data</code> <code>dict</code> <p>Dictionary of fields to update.</p> required <p>Returns:</p> Type Description <code>Vtt</code> <p>Updated Vtt instance.</p> Source code in <code>website/services/vtt.py</code> <pre><code>def update(self, id: int, data: dict) -&gt; Vtt:\n    \"\"\"Update an existing VTT.\n\n    Args:\n        id: VTT ID.\n        data: Dictionary of fields to update.\n\n    Returns:\n        Updated Vtt instance.\n    \"\"\"\n    vtt = self.repo.get_by_id_or_404(id)\n    vtt.update_from_dict(data)\n    db.session.commit()\n    cache.delete_memoized(self.get_all)\n    return vtt\n</code></pre>"},{"location":"architecture/services/#website.services.VttService.delete","title":"<code>delete(id)</code>","text":"<p>Delete a VTT.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>VTT ID.</p> required Source code in <code>website/services/vtt.py</code> <pre><code>def delete(self, id: int) -&gt; None:\n    \"\"\"Delete a VTT.\n\n    Args:\n        id: VTT ID.\n    \"\"\"\n    vtt = self.repo.get_by_id_or_404(id)\n    self.repo.delete(vtt)\n    db.session.commit()\n    cache.delete_memoized(self.get_all)\n</code></pre>"},{"location":"architecture/utils/","title":"Utils","text":"<p>The utils layer lives in <code>website/utils/</code> and provides helper functions shared across the application.</p>"},{"location":"architecture/utils/#overview","title":"Overview","text":"Module Description <code>form_parsers</code> Extract classification scores, ambience, and restriction tags from Flask forms <code>game_embeds</code> Build Discord embed dictionaries for announcements, sessions, registrations, and alerts <code>game_filters</code> Paginated game search with multi-checkbox filters and status-based visibility rules <code>logger</code> Request-aware logging with trace IDs and game event convenience wrapper"},{"location":"architecture/utils/#api-reference","title":"API Reference","text":"<p>Utility modules for logging, filters, and helpers.</p>"},{"location":"architecture/utils/#website.utils.get_app_version","title":"<code>get_app_version()</code>","text":"<p>Return the application version.</p> <p>Reads the version from the installed package metadata (pyproject.toml), falling back to the TAG environment variable (set by docker-compose).</p> <p>Returns:</p> Type Description <code>str</code> <p>The application version string, or 'dev' if neither source is available.</p> Source code in <code>website/utils/__init__.py</code> <pre><code>def get_app_version() -&gt; str:\n    \"\"\"Return the application version.\n\n    Reads the version from the installed package metadata (pyproject.toml),\n    falling back to the TAG environment variable (set by docker-compose).\n\n    Returns:\n        The application version string, or 'dev' if neither source is available.\n    \"\"\"\n    try:\n        return version(\"questmaster\")\n    except Exception:\n        pass\n    tag = os.environ.get(\"TAG\")\n    if tag:\n        return tag\n    return \"dev\"\n</code></pre>"}]}